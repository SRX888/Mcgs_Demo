<resources>
    <string name="app_name">Mcgs-demo</string>
    <string name="title_docment">文档</string>
    <string name="title_application">应用</string>
    <string name="title_settings">设置</string>
    <string name="version_name">mcgs_1.1.01</string>


    <string name="app_rotation_title">屏幕旋转</string>

    <string name="system_documentation">
            "1.  概述\n"
            "A64 平台快速移植文档，本文基于 A64 tulip-t1 方案。\n"
            "1.1.  名词解释\n"
            "1.  vendor-name\n"
            "softwinner\n"
            "2.  device-name\n"
            "tulip-t1\n"
            "3.  product-name\n"
            "tulip_t1\n"
            "\n"
            "可以在下面路径的文件查看以上的属性\n"
            "a64-android6.0/android/device/softwinner/tulip-p1/tulip_p1.mk\n"
            "\n"
            "\n"
            "2.  方案定制\n"
            "方案目录 device/vendor-name/device-name/\n"
            "\n"
            "2.1.  overlay  说明\n"
            "\n"
            "Android overlay 机制允许在不修改 apk 或者 framework 源代码的情况下，实现资源的定制。\n"
            "以下几类能够通过 overlay 机制定义：\n"
            "1.  Configurations (string, bool, bool-array)\n"
            "2.  Localization (string, string-array)\n"
            "3.  UI Appearance (color, drawable, layout, style, theme, animation)\n"
            "4.  Raw resources (audio, video, xml)\n"
            "更详细的资源文件可浏览 android 网站：\n"
            "http://developer.android.com/guide/topics/resources/available-resources.html\n"
            "\n"
            "2.1.1.  为产品添加 Overlay  目录\n"
            "\n"
            "有两种不同的 overlay 目录定义：\n"
            "1.  PRODUCT_PACKAGE_OVERLAYS\n"
            "用于指定产品\n"
            "2.  DEVICE_PACKAGE_OVERLAYS\n"
            "用于同一设备模型的一系列产品\n"
            "如果包含同一资源，那么 PRODUCT_PACKAGE_OVERLAYS 将覆盖\n"
            "DEVICE_PACKAGE_OVERLAYS 。如果要定义多个 overlays 目录，需要用空格隔开，同一资源的\n"
            "定义，将使用先定义的目录中的资源。\n"
            "在方案目录下创建 overlay 和 product-name/overlay 目录，分别用于 device 通用及 product 使用的overlay 文件夹。\n"
            "\n"
            "\n"
            "2.1.2.  改变 mk  文件来添加 overlays  的编译项\n"
            "\n"
            "在文件 device/vendor-name/device-name/product-name.mk 中添加：\n"
            "\n"
            "PRODUCT_PACKAGE_OVERLAYS := \\\n"
            "device/vendor-name/device-name/product-name/overlay \\\n"
            "$(PRODUCT_PACKAGE_OVERLAYS)\n"
            "DEVICE_PACKAGE_OVERLAYS := \\\n"
            "device/vendor-name/device-name/overlay \\\n"
            "$(DEVICE_PACKAGE_OVERLAYS)\n"
            "\n"
            "注：\n"
            "必须加上$(PRODUCT_PACKAGE_OVERLAYS)变量否则将找不到默认资源。\n"
            "\n"
            "\n"
            "\n"
            "2.1.3. 在  overlay  目录下创建资源文件\n"
            "\n"
            "在 overlay 目录下创建和要替换资源所在文件相同的路径的文件，此路径是相对于 android platform 目录。如替换 framework-res 路径为：platform/framework/base/core/res/res/value/config.xml中的某一项，则在 overlay 中创建对应的路径：overlay/framework/base/core/res/res/value/config.xml 并添加要修改的一向配置，如：\n"
            "\n"
            "<integer name="config_multiuserMaximumUser">4</integer>"\n"

    "\n"
    "\n"
    "2.2.  装 预装 APK\n"
    "\n"
    "预装 apk 安装有两种方法，可以安装到 system/app 目录下，也可以安装到 system/preinstall 或system/precopy 目录下。注：apk 名字不能含有中文、空格等特殊字符。\n"
    "\n"
    "\n"
    "2.2.1.  默认预装 APK\n"
    "\n"
    "   APK              说明\n"
    "ES 文件管理器    文件管理器\n"
    "VideoPlayer      4K 播放器\n"
    "DragonAging      工厂测试应用\n"
    "DragonFire       工厂测试应用\n"
    "DragonPhone      工厂测试应用\n"
    "\n"
    "\n"
    "2.2.2.  预装到 system/app  目录\n"
    "1. 在目录 device/softwinner/common/prebuild/apk/中创建一个目录存放对应 APK。\n"
    "2. 将 apk 放入该目录中。\n"
    "3. 将 apk 使用 winrar 打开，将 lib/armeabi 下的 so 库解压到 lib/arm/目录中。\n"
    "4. 在同目录的 Android.mk 文件中加入：\n"
    "\n"
    "# Example\n"
    "LOCAL_PATH := $(call my-dir)\n"
    "include $(CLEAR_VARS)\n"
    "LOCAL_MODULE := APK_MODULE_NAME（模块的唯一名字）\n"
    "LOCAL_MODULE_CLASS := APPS\n"
    "LOCAL_MODULE_TAGS := optional\n"
    "LOCAL_BUILT_MODULE_STEM := package.apk\n"
    "LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)\n"
    "#LOCAL_PRIVILEGED_MODULE :=\n"
    "LOCAL_CERTIFICATE := PRESIGNED\n"
    "#LOCAL_OVERRIDES_PACKAGES := OVERRIDES_MODULE（要替代的模块）\n"
    "LOCAL_SRC_FILES := name.apk（apk 的文件名，一般与 MODULE 同名）\n"
    "#LOCAL_REQUIRED_MODULES :=\n"
    "LOCAL_PREBUILT_JNI_LIBS := lib/$(TARGET_ARCH)/libjni.so \n"
    "include $(BUILD_PREBUILT)\n"
    "\n"
    "5. 在方案 mk 文件（device/vendor-name/device-name/product-name.mk）中 PRODUCT_PACKAGES 项中加入\n"
    "\n"
    "PRODUCT_PACKAGES += APK_MODULE_NAME（apk 模块名字，预装多个 apk 用空格隔开）\n"
    "\n"
    "\n"
    "2.2.3.  预装到 system/preinstall  目录\n"
    "\n"
    "1.这些 apk 将在系统第一次启动时安装到用户 data 目录，用户可自行卸载。\n"
    "2.将 apk 放入 device/vendor-name/common/prebuild/preinstallapk/目录中，并且在同目录的 Android.mk文件中加入：\n"
    "\n"
    "include $(CLEAR_VARS)\n"
    "LOCAL_MODULE := APK_MODULE_NAME（模块的唯一名字）\n"
    "LOCAL_MODULE_TAGS := optional\n"
    "LOCAL_CERTIFICATE := PRESIGNED\n"
    "LOCAL_MODULE_PATH := $(TARGET_OUT)/preinstall\n"
    "LOCAL_MODULE_CLASS := APPS\n"
    "LOCAL_SRC_FILES := name.apk（同目录下 apk 的文件名）\n"
    "LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)\n"
    "include $(BUILD_PREBUILT)\n"
    "\n"
    "\n"
    "3.在方案 mk 文件（device/vendor-name/device-name/product-name.mk）中 PRODUCT_PACKAGES 项中加入：\n"
    "\n"
    "2.2.4.  预装到 system/precopy \n"
    "\n"
    "1.这些 apk 将在系统第一次启动时，在 Launcher 启动之前安装到用户 data 目录，用户可自行卸载。\n"
    "2.将 apk 放入 device/vendor-name/common/prebuild/preinstallapk/目录中，并且在同目录的 Android.mk文件中加入：\n"
    "\n"
    "include $(CLEAR_VARS)\n"
    "LOCAL_MODULE := APK_MODULE_NAME（模块的唯一名字）\n"
    "LOCAL_MODULE_TAGS := optional\n"
    "LOCAL_CERTIFICATE := PRESIGNED\n"
    "LOCAL_MODULE_PATH := $(TARGET_OUT)/precopy\n"
    "LOCAL_MODULE_CLASS := APPS\n"
    "LOCAL_SRC_FILES := name.apk（同目录下 apk 的文件名）\n"
    "LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)\n"
    "include $(BUILD_PREBUILT)\n"
    "\n"
    "3.在方案 mk 文件（device/vendor-name/device-name/product-name.mk）中 PRODUCT_PACKAGES 项中加入：\n"
    "PRODUCT_PACKAGES += APK_MODULE_NAME（apk 模块名字，预装多个 apk 用空格隔开）\n"
    "\n"
    "\n"
    "2.3. 配置 data 分区\n"
    "\n"
    "data 分区大小可以由 BoardConfig.mk 文件的 BOARD_USERDATAIMAGE_PARTITION_SIZE 指定，单位是字节。\n"
    "\n"
    "注：\n"
    "多用户方案一般将最后一个分区作为 data 分区，该分区大小是 Nand 或者 eMMC 总容量减去其他分区大小；如果需要烧写 data 分区镜像，分区大小需要预留一定预度，防止超出 Nand 或者 eMMC容量。\n"
    "\n"
    "2.4.  动 修改启动 LOGO\n"
    "\n"
    "启动 LOGO 为初始引导阶段的 LOGO。将启动 logo 放入位置：lichee/tools/pack/chips/sunxi/configs/device-name/bootlogo.bmp\n"
    "\n"
    "\n"
    "2.5.  修改启动动画\n"
    "\n"
    "将动画放入：device/vendor-name/device-name/media/bootanimation.zip\n"
    "bootanimation 格式：bootanimation.zip 包含 part0 part1 文件夹和 desc.txt 文件，part0，part1 文件夹里面放的是动画拆分的图片，格式为 png 或 jpg。desc.txt 文件内容如下：\n"
    "\n"
    "800 480 15\n"
    "p 1 0 part0\n"
    "p 0 0 part1\n"
    "\n"
    "说明：\n"
    "第一行：800 为宽度，480 为高度，15 为帧数。第二行开始 p 为标志符，接下来第二列为循环次数（０为无限循环），第三项为两次循环之间间隔的帧数，第四项为对应的目录名。播放动画时会按照图片文件名顺序自动播放。\n"
    "\n"
    "\n"
    "开机音乐：\n"
    "如需开机音乐，将开机音乐放入 part0 目录中，命名为 audio.wav。在根目录中加入 audio_conf.txt，内容如下：\n"
    "\n"
    "card=0\n"
    "device=0\n"
    "period_size=2048\n"
    "period_count=2\n"
    "mixer \"Speaker Function\"=spk\n"
    "mixer \"AIF1IN0L Mux\"=AIF1_DA0L\n"
    "mixer \"AIF1IN0R Mux\"=AIF1_DA0R\n"
    "mixer \"DACL Mixer AIF1DA0L Switch\"=1\n"
    "mixer \"DACR Mixer AIF1DA0R Switch\"=1\n"
    "mixer \"Left Output Mixer DACL Switch\"=1\n"
    "mixer \"Left Output Mixer DACR Switch\"=1\n"
    "mixer \"SPK_L Mux\"=MIXL MIXR Switch\n"
    "mixer \"SPK_R Mux\"=MIXR MIXL Switch\n"
    "mixer \"External Speaker Switch\"=1\n"
    "\n"
    "\n"
    "打包格式要求：\n"
    "windows 使用 winrar 打包，选择 ZIP 格式，压缩标准要选“储存”；linux 下，zip -0 -r ../bootanimation.zip ./* linux 命令使用-0 指定压缩等级为最低等级 stored，即只归档不压缩，否则可能由于包格式问题引起动画显示为黑屏。打包完之后修改其权限值：chmod 666 bootanimation.zip\n"
    "\n"
    "\n"
    "使用adb psuh  bootanimation.zip  /system/media/ \n"
    " adb reboot   即可验证效果\n"
    "\n"
    "\n"
    "2.6.  修改充电图标\n"
    "\n"
    "在 android 目录下执行\n"
    "python bootable/recovery/interlace-frames.py battery1.png battery2.png ... batteryn.png battery_scale.png然后将生成的 battery_scale.png 替换 system/core/healthd/images/目录下 battery_scale.png其中[battery1.png battery2.png ... batteryn.png ]为充电动画的图标。如图片数量不同需修改代码 system/core/healthd/healthd_mode_charger.cpp\n"
    "\n"
    "\n"
    "2.7.  制 定制 recovery  功能\n"
    "\n"
    "Recovery 是 Android 的专用升级模式，用于对 android 自身进行更新；进入 recovery 模式的方法是，在 android 系统开机时，按住一个特定按键，则会自动进入 android 的 recovery 模式。\n"
    "\n"
    "2.7.1.  功能使用\n"
    "\n"
    "在 android 编译完毕之后，使用如下命令\n"
    "$ pack4dest\n"
    "$ ./build/tools/releasetools/ota_from_target_files target-file.zip ota.zip\n"
    "就可以生成一个 ota.zip 文件。在系统启动时，按住设定的特定按键进入 recovery 模式，进入该模式后，可以选择升级文件升级。\n"
    "\n"
    "\n"
    "2.8.  内存自适应\n"
    "\n"
    "2.8.1.  预留内存设置\n"
    "一般不需要改, 如果确实是预留内存不足, 导致 ion 分配失败, 可以修改这里加大预留:\n"
    "文件: lichee/tools/pack/chips/sunxi/configs/default/env.cfg\n"
    "cma=256M\n"
    "\n"
    "2G 内存平台,假设需要预留 256M。如果需要调整预留内存大小,可以直接修改cma变量。\n"
    "注: 预留内存, 指的是 CMA 预留内存, 这部分内存空闲时, 可以被系统用.\n"
    "\n"
    "\n"
    "2.8.2.  内存参数调节\n"
    "\n"
    "一般不需要改. 这里为使客户理解, 对内存参数进行说明:\n"
    "文件: device/softwinner/common/config/config_mem.ini\n"
    "\n"
    "(1) 虚拟机参数:\n"
    "[dalvik_512m], [dalvik_1024m], [dalvik_2048m]分别表示512M, 1G, 2G内存方案上的虚拟机参数.具体包括 dalvik.vm.heapsize, dalvik.vm.heapstartsize, dalvik.vm.heapgrowthlimit, dalvik.vm.heapminfree,\n"
    "dalvik.vm.heapmaxfree. 这些参数含义可以在网上找到.\n"
    "\n"
    "[dalvik_512m] (512M 方案虚拟机堆参数)\n"
    "dalvik.vm.heapsize=128m\n"
    "dalvik.vm.heapstartsize=5m\n"
    "dalvik.vm.heapgrowthlimit=48m\n"
    "dalvik.vm.heaptargetutilization=0.75\n"
    "dalvik.vm.heapminfree=512k\n"
    "dalvik.vm.heapmaxfree=2m\n"
    "[dalvik_1024m] (1024M 方案虚拟机堆参数)\n"
    "dalvik.vm.heapsize=384m\n"
    "dalvik.vm.heapstartsize=8m\n"
    "dalvik.vm.heapgrowthlimit=64m\n"
    "dalvik.vm.heaptargetutilization=0.75\n"
    "dalvik.vm.heapminfree=512k\n"
    "dalvik.vm.heapmaxfree=8m\n"
    "[dalvik_2048m] (2048M 方案虚拟机堆参数)\n"
    "# dalvik.vm.heapsize=384m (#开头表示注释, 即使用系统默认的参数)\n"
    "# dalvik.vm.heapstartsize=8m\n"
    "# dalvik.vm.heapgrowthlimit=64m\n"
    "# dalvik.vm.heaptargetutilization=0.75\n"
    "# dalvik.vm.heapminfree=512k\n"
    "# dalvik.vm.heapmaxfree=8m\n"
    "\n"
    "\n"
    "(2) hwui 参数:\n"
    "[hwui_800], [hwui_1024], [hwui_1280], [hwui_1920], [hwui_2048], [hwui_2560]. 数字表示 lcd 分辨率的长边像素. 比如 1280*800, 1280*720 的屏, 其对应 hwui 参数是[hwui_1280]. 更详细的参数介绍可参考：https://source.android.com/devices/tech/debug/tuning.html.\n"
    "\n"
    "\n"
    "[hwui_800]\n"
    "[hwui_1024]\n"
    "[hwui_1280] (默认设置是针对 1280*800，所以大部分采用默认设置）\n"
    "#ro.hwui.texture_cache_size=24 (texture cache，MB，至少 5 于 width * height * 32bit)\n"
    "#ro.hwui.layer_cache_size=16 (layer cache，MB，至少 4 倍于 width * height * 32bit)\n"
    "#ro.hwui.r_buffer_cache_size=2 (renderbuffer cache，MB，至少 2 倍于 width * height * 8bit)\n"
    "#ro.hwui.path_cache_size=10 (path cache，MB，至少 1 倍于 width * height * 32bit)\n"
    "#ro.hwui.drop_shadow_cache_size=2 (text drop shadow cache，MB，至少 2 倍于 width * height * 8bit)\n"
    "#ro.hwui.text_small_cache_width=1024 (pixels)\n"
    "#ro.hwui.text_small_cache_height=512 (pixels)\n"
    "#ro.hwui.text_large_cache_width=2048 (pixels)\n"
    "#ro.hwui.text_large_cache_height=512 (pixels)\n"
    "#ro.hwui.gradient_cache_size=0.5 (gradient cache，MB)\n"
    "#ro.hwui.vertex_cache_size=1 (tessellation cache，MB)\n"
    "#ro.hwui.patch_cache_size=128 (KB)\n"
    "#ro.hwui.texture_cache_flushrate=0.6 (flush 后保留的 texture cache 的比例）\n"
    "#ro.hwui.disable_scissor_opt=false\n"
    "[hwui_1920]\n"
    "[hwui_2048]\n"
    "[hwui_2560]\n"
    "\n"
    "\n"
    "\n"
    "\n"
    "2.9.  配置单用户说明\n"
    "\n"
    "1.修改分区表配置（lichee/tools/pack/chips/sunxi/configs/device-name/sys_partition.fex），添加 data分区：\n"
    "\n"
    "------------------------------>mmcblk0p8/nande\n"
    "[partition]\n"
    "name = data\n"
    "size = 2097152\n"
    "user_type = 0x8000\n"
    "\n"
    "2.设置用户数为 1，修改文件 platform/framework/base/core/res/res/value/config.xml\n"
    "<integer name="config_multiuserMaximumUsers">1</integer>\n"
    "\n"
    "注：可通过 overlay 方式修改，具体请参照 2.1overlay 说明。\n"
    "\n"
    "\n"
    "3.修改方案 mk 文件（device/vendor-name/device-name/product-name.mk），将 persist.sys.usb.config属性的 mtp 改为 mass_storage\n"
    "\n"
    "\n"
    "4.修改存储列表文件 platform/frameworks/base/core/res/res/xml/storage_list.xml\n"
    "\n"
    "StorageList xmlns:android="http://schemas.android.com/apk/res/android\n""
    "storage android:mountPoint=\"/storage/sdcard\"\n"
    "android:storageDescription=\"@string/storage_internal\"\n"
    "android:primary=\"true\"\n"
    "android:removable=\"false\"\n"
    "android:emulated=\"false\"\n"
    "android:mtpReserve=\"100\"\n"
    "android:allowMassStorage=\"true\"\n"
    "android:maxFileSize=\"0\" />\n"
    "<!-- extsd -->\n"
    "storage android:mountPoint=\"/storage/extsd\"\n"
    "android:storageDescription=\"@string/storage_sd_card\"\n"
    "android:primary=\"false\"\n"
    "android:removable=\"true\"\n"
    "android:emulated=\"false\"\n"
    "android:mtpReserve=\"0\"\n"
    "android:allowMassStorage=\"true\"\n"
    "android:maxFileSize=\"0\" \n"
    "<!-- usbhost -->\n"
    "storage android:mountPoint=\"/storage/usbhost\"\n"
    "android:storageDescription=\"@string/storage_usb\"\n"
    "android:primary=\"false\"\n"
    "android:removable=\"true\"\n"
    "android:emulated=\"false\"\n"
    "android:mtpReserve=\"0\"\n"
    "android:allowMassStorage=\"true\"\n"
    "android:maxFileSize=\"0\" \n"
    "StorageList\n"
    "\n"
    "\n"
    "注：可通过 overlay 方式修改，具体请参照 2.1overlay 说明。\n"
    "\n"
    "\n"
    "\n"
    "3. Settings  设置\n"
    "\n"
    "3.1.  认 默认 LCD  关闭时间设置\n"
    "\n"
    "frameworks/base/packages/SettingsProvider/res/values/defaults.xml 中设置（单位为毫秒）：\n"
    ""def_screen_off_timeout"设为 60000\n"
    "注：可通过 overlay 方式修改，具体请参照 2.1overlay 说明。\n"
    "\n"
    "3.2.  默认亮度设置\n"
    "\n"
    "platform/frameworks/base/packages/SettingsProvider/res/values/defaults.xml 中设置，亮度值从 0~255 表示 0%~100%，如设置 102 则默认亮度为 40%，示例如下：\n"
    "<integer name="def_screen_brightness">102</integer>\n"
    "注：可通过 overlay 方式修改，具体请参照 2.1overlay 说明。\n"
    "\n"
    "3.3.  默认字体大小设置\n"
    "\n"
    "系统字体由 fontScale 来控制缩放，设置菜单中的小，普通，大，超大分别对应的 fontScale 为 0.85、1.0、1.15、1.3，修改默认字体大小可在 device/vendor-name/device-name/product-name.mk 中设置ro.font.scale 的值来设置默认的字体大小。\n"
    "如：\n"
    "PRODUCT_PROPERTY_OVERRIDES += \\\n"
    "ro.font.scale=1.0\n"
    "注：建议采用默认设置，即 ro.font.scale=1.0，过 CTS 默认必须是 1.0。\n"
    "\n"
    "3.4.  蓝牙选项设置\n"
    "\n"
    "device/vendor-name/device-name/product-name.mk，添加以下信息：\n"
    "PRODUCT_COPY_FILES += \\\n"
    "frameworks/native/data/etc/android.hardware.bluetooth.xml:system/etc/permissions/android.hardware.bluetooth.xml即可打开蓝牙选项\n"
    "\n"
    "\n"
    "3.5.  Miracast  功能设置\n"
    "\n"
    "platform/frameworks/base/core/res/res/values/config.xml 中设置：\n"
    "name="config_enableWifiDisplay" 设为 false\n"
    "注：可通过 overlay 方式修改，具体请参照 2.1overlay 说明。Miracast 只能在 1GB DDR 以上的方案实现，并保证 BoardConfig.mk 中的 ion_reserve 为 100MB 以上。\n"
    "\n"
    "\n"
    "4. Launcher及界面设置\n"
    "\n"
    "4.1.  默认壁纸设置\n"
    "\n"
    "替换文件 platform/frameworks/base/core/core/res/drawable-swxxxdp-nodpi/default_wallpaper.jpg，\n"
    "可通过 overlay 方式将文件放在 device/vendor-name/device-name/platform/frameworks/base/core/core/\n"
    "res/drawable-swxxxdp-nodpi/default_wallpaper.jpg。\n"
    "\n"
    "4.3.  Launcher  默认图标和快捷栏设置\n"
    "\n"
    "修改文件 platform/packages/apps/Launcher2/res/xml-swxxxdp/default_workspace.xml，文件中各配置项含义如下：\n"
    "设置名         意义\n"
    "packageName  所运行的 APP 的 package 名，可到具体路径去查找，如在Setting.java 中 第 一 行 有 效 代 码 会 显 示 包 名 packagecom.android.settings;\n"
    "className  点击需要启动的该 APP 的 Activity 的 class 名，其表示方式如下packageName.ActivityName\n"
    "\n"
    "screen  表示在第几个，根据显示的个数决定\n"
    "x  放在该屏的第几行\n"
    "y  放在该屏的第几列\n"
    "注：可通过 overlay 方式修改，具体请参照 2.1overlay 说明。\n"
    "\n"
    "\n"
    "5.  系统调试\n"
    "\n"
    "5.1.  成 生成 debug  固件\n"
    "\n"
    "Android 编译时使用 pack -d 即可生成 debug 固件，该固件将串口引入卡口打印出来，配合配套\n"
    "的工具即可实时查看 log 信息。\n"
    "\n"
    "5.2.  用 使用 fastboot\n"
    "5.2.1.  进入 fastboot  模式\n"
    "\n"
    "系统 SDK 中默认方式是无法进入 fastboot 的，如果在调试中想要进入 fastboot 可以修改\n"
    "lichee/tools/pack/chips/sunxi/configs/default/env.cfg 文件中的 bootdelay 的值为非零值即可，单位为秒，该值影响启动内核前的等待时间，在该等待时间内从串口输入任意字符即可进入 uboot 命令环境。\n"
    "\n"
    "按照如下步骤操作：\n"
    "1.  修改 lichee/tools/pack/chips/sunxi/configs/default/env.cfg 中的 bootdelay=3\n"
    "2.  启动倒计时输入任意字符进入 uboot，然后输入 fastboot 命令即进入 fastboot 模式\n"
    "3.  在 PC 端执行 fastboot 命令即可进行 fastboot 操作\n"
    "4.  小机端 Ctrl+C 可退出 fastboot 模式\n"
    "\n"

    ></string>

    <string name="developer_guide_documentation">
            "一、源码目录的基本介绍\n"
            "通过git clone 从gitlab clone下来的source code，包括Android 的source code 和lichee 的source code 及readme.txt.\n"
            "\n"
            "其中android 目录为Android M 的source code；\n"
            "lichee目录为A64的内核的source code；\n"
            "readme.txt  是编译的相关说明；\n"
            "\n"
            "gitlab仓库地址：https://gitlab.com/mcgs-a64-android/a64-android6.0\n"
            "clone source code: git clone git@gitlab.com:mcgs-a64-android/a64-android6.0.git\n"
            "\n"
            "需要联系管理开通权限才能\n"
            "\n"
            "\n"
            "1.1   Android 目录树介绍\n"
            "\n"
            "android 目录下是的 android 源码，A64 使用的 android 系统为 android 6.0。\n"
            "查看 android 的目录树结构，在 android 的根目录下文件与 android 官方源码相同。\n"
            "\n"
            "1.2 lichee 目录结构\n"
            "lichee 目录下包含 buildroot 工具、linux 内核、以及 uboot 源码。查看 lichee 的目录结构，\n"
            "在 lichee 的根目录下执行下面的命令\n"
            "\n"
            "brandy目录：\n"
            "存放 boot0 和 u-boot 源码，brandy 源码一共包含以下几个部分：用于烧录的 fes1，用于启动的 boot0，用于烧写和启动的uboo。\n"
            "\n"
            "buildroot目录：\n"
            " 管理编译脚本和交叉编译工具链\n"
            " 定制开发 DragonBoard 测试用例\n"
            " 制作 Linux 固件的根文件系统，\n"
            "    可以包含 strace, directfb, oprofile 等非常丰富的应用软件和测试软件。\n"
            "\n"
            "linux-3.10目录：\n"
            "以上目录结构跟标准的 Linux 内核一致，除了 modules 目录。modules 目录是我们用来存放没有跟内核的 menuconfig 集成的外部模块的地方。我们目前放了 aw_schw, gpu 和 nand 这 3 个外部模块，其中 aw_schw 是密钥模块：存储 key，gpu 是 GPU 驱动，nand 是 nand 驱动。\n"
            "\n"
            "tools目录：\n"
            "该目录存放方案系统配置、打包脚本和工具，以及部分平台相关的工具。\n"
            "\n"
            "以上就是对A64 源码的一个基本的介绍。\n"
            "\n"
            "二、编译\n"
            "\n"
            "2.1  lichee 源码编译\n"
            "使当前目录为 lichee 的根目，编译全志A64的内核。然后执行下面的命令：\n"
            "./build.sh\n"
            "\n"
            "即完成了一次 lichee 的编译（根据服务器配置，耗时至少 10 分钟），编译成功，屏幕上会出现\n"
            "INFO:build u-boot OK.\n"
            "...\n"
            "INFO:build rootfsOK.\n"
            "INFO:build lichee OK.\n"
            "\n"
            "…………………………………………\n"
            "\n"
            "完成了一次 lichee 的编译。\n"
            "\n"
            "2.2 Android source code的编译\n"
            "在确保 lichee 已经编译，并且使当前目录为 android 的根目录。然后执行下面的命令\n"
            "$ . build/envsetup.sh     #导入环境变量\n"
            "$ lunch      #根据自己的开发平台，选择方案\n"
            "$ extract-bsp    #拷贝内核和模块到 android 中\n"
            "$ make -j8       #-j 开启多核编译，服务器开发一般为服务器 cpu 数量的一半\n"
            "   编译成功，会在 out/target/product/tulip-xxx/ 目录下面会生成 boot.img, recovery.img,system.img 3个包。\n"
            "\n"
            "\n"
            "\n"
            "其中 extract-bsp 拷贝安卓内核到源码目录\n"
            "\n"
            "三、 打包固件\n"
            "两种打包方式，一种是完全打包，一种是局部打包\n"
            "\n"
            "3.1  完全打包\n"
            "在保证 lichee 和 android 都编译完成的基础上， 相关环境变量已经导入， 只需要在 android的根目录下执行下列命令即可\n"
            "$ pack\n"
            "打包成功后，将会在 lichee/tools/pack 目录下生成 sun50iw1p1_android_xxx.img 文件，即生成我们所需的固件.\n"
            "生成我们所需的固件，使用 PhoenixSuit 烧写固件即可。\n"
            "\n"
            "3.2  局部打包\n"
            "boot.img 镜像中包含 linux kernel 和内存盘 ramdisk，如果内核有修改，就需要重新编译内核，然后再 android 目录下执行下列命令 ,即可打包生成 boot.img\n"
            "\n"
            "$ . build/envsetup.sh\n"
            "$ lunch \n"
            "$ extract-bsp\n"
            "$ make bootimage\n"
            "这样就生成了 boot.img ，类似的方法就可以可以重新打包生成 system.img\n"
            "$ . build/envsetup.sh\n"
            "$ lunch \n"
            "$ make systemimage-nodeps\n"
            "\n"
            "重新生成的镜像在 android 目录下的 out/target/product/tulip-xxx/目录下\n"
            "\n"
            "\n"
            "四、固件烧写\n"
            "\n"
            "4.1 使用 PhoenixSuit 烧写固件\n"
            "\n"
            "安装好 PhoenixSuit 后，双击运行，单机一键刷机，选择我们生成的固件， 如果已经烧入 android 系统，开机后与 windows 主机连接好，单机立即升级即可自动烧入新的固件。\n"
            "\n"
            "4.2 使用 fastboot 更新系统（对于开发人员）\n"
            "\n"
            "fastboot 是一种线刷，就是使用 USB 数据线连接手机的一种刷机模式，在 A64 主控中，可以使用 fastboot 的功能来实现局部系统的更新。\n"
            "\n"
            "4.2.1进入 fastboot 模式\n"
            "\n"
            "启动开发板，在串口界面敲任意按键，可以进入 u-boot；如果进不了 fastboot，将lichee\\tools\\pack\\chips\\sun7i\\configs\\android\\default\\env.cfg 中 的 bootdelay=0 改 成bootdelay=2 重新打包固件即可（需要安装 google-usb_driver 驱动）。\n"
            "\n"
            "在串口命令行输入 fastboot 命令，进入 fastboot 模式；\n"
            "通过 pc 端的 fastboot 工具烧录各个固件包（ fastboot 是 windows 下的一个工具（android sdk 中有），上网自己下载一个，解压到本地，然后将 fastboot.exe 添加到windows 环境变量）\n"
            "?进入在 windows 命令行： cmd 进行命令行模式，于是可以在命令行执行 fastboot 指令 退出 fastboot 模式： ctlc\n"
            "\n"
            "4.2.2 fastboot 命令使用\n"
            "\n"
            "在 windows 命令行使用 fastboot 命令。\n"
            "擦除分区命令：\n"
            "$ fastboot erase boot #檫除 boot 分区\n"
            "$ fastboot erase system #檫除 system 分区\n"
            "$ fastboot erase data #檫除 data分区\n"
            "烧写分区命令：\n"
            "$ fastboot flash boot boot.img #把 boot.img 烧写到 boot 分区\n"
            "$ fastboot flash system system.img #把 system.img 烧写到 system 分区\n"
            "$ fastboot flash data userdata.img #把 userdata.img 烧写到 data分区\n"
            "\n"
            "\n"
            "五、调试\n"
            "本节介绍如何生成调试应用和固件的方式方法\n"
            "5.1 调试 apk\n"
            "修改应用程序 Gallery2 ，编译修改推送到小机\n"
            "$ . build/envsetup.sh\n"
            "$ lunch \n"
            "$ cd packages/apps/Gallery2\n"
            "$ mm\n"
            "执行“ mm”命令局部编译 Gallery2 应用程序，生成 Gallery2Tests.apk。如下所示。\n"
            "Install: out/target/product/tulip-xxx/data/app/Gallery2Tests.apk\n"
            "然后在 windows 命令行下将生成的 Gallery2Tests.apk 推送到设备的相应目录 system/app\n"
            "下即可（注：需要预先安装 adb）。如下所示：\n"
            "在 windows 命令行： cmd 进入命令行模式。\n"
            ">adb push Gallery2Tests.apk /system/app/\n"
            "\n"
            "\n"
            "5.2 调试 android 系统\n"
            "在 android 目录下执行以下指令， 在 out/target/product/ tulip-xxx /目录下生成 android  system.img 。\n"
            "$ . build/envsetup.sh\n"
            "$ lunch \n"
            "$ make \n"
            "通过 fastboot 工具刷到小机：\n"
            "  重新启动开发板，在串口界面敲任意按键，可以进入 u-boot；\n"
            "  在串口命令行输入 fastboot 命令，进入 fastboot 模式；\n"
            " 进入在 windows 命令行： cmd 进行命令行模式，在命令行执行 fastboot 指令 (前提是已经安装了 fastboot 工具 )，将 system.img 拷贝到小机上即可。\n"
            "$ fastboot erase system\n"
            "$ fastboot flash system system.img\n"
            "\n"
            "\n"
            "\n"
            "\n"
            "\n"
            "\n"</string>
    <string name="rotation_documentation">"Android 屏幕旋转的机制默认情况下通过重力感应器（G-sensor）来实现的，带有G-sensor的Android设备上可通过API获取到设备的运动加速度，应用程序通过一些假设和算法运算，可以从加速度计算出设备的方向，通过计算出来的值。PhoneWindownManager 通过注册一个ContentObserver来监听用户设置的变化，当用户设置变化后调用updateSettings（）函数，做设置变化的更新和做相应的动作。WindowManagerService完成屏幕旋转的功能，首先更新屏幕方向，然后具体实施屏幕旋转，最后通知AMS configuration变更。\n"
            "\n"
            "上面的所说的都是基于Android设备的具有G-sensor的模块，通过监听G-sensor数据的变化实现屏幕的旋转。但是对于没有G-sensor的模块的设备或者通过想要通过按键来触发屏幕的旋转，怎么实现呢？\n"
            "\n"
            "不管是通过G-sensor设备还是通过按键或者其他的方式来触发屏幕旋转的流程都一样的，只是提供数据的方式有区别而已。\n"
            " \n"
            "\n"
            "\n"
            "其实现机制为：当Configuration改变后，ActivityManagerService将会发送\"配置改变\"的广播，会要求ActivityThread重新启动当前focus的Activity，这是默认情况。如果想很好地支持屏幕旋转，则建议在res中建立layout-land和layout-port两个文件夹，把横屏和竖屏的布局文件放入对应的layout文件夹中。如果不申明android:configChanges=\"\"，按照Activity的生命周期，都会去执行一次onCreate()方法，而onCreate()方法通常会在显示之前做一些初始化工作。这样就有可能造成重复的初始化，必然降低程序效率，而且更有可能因为重复的初始化而导致数据的丢失。\n"
            "\n"
            "\n"
            "\n"
            "目前的A64 Android 设备就是没有G-sensor的模块，具体的实现的就是通过按键或者一些操作模拟G-sensor数据，再把数据传给WindowManagerService，最后通过WindowManagerService判断的接收的数据控制屏幕旋转。\n"
            "\n"
            "\n"
            "现在从Android APP（单个应用的旋转，只有在APP界面内旋转）和系统级别的旋转（一旦选择，不管重启还是其他行为都保持该旋转的模式），分别从0,90,180,270 四个角度进行旋转。\n"
            "\n"
            "\n"
            "（一）APP 四个角度的旋转：\n"
            "在APP界面通过按键来实现APP的旋转\n"
            "有2种方式控制屏幕方向：\n"
            "（1）修改AndroidManifest.xml\n"
            "1 在AndroidManifest.xml的activity中加入:\n"
            "横屏：\n"
            "android:screenOrientation=”landscape”\n"
            "竖屏：\n"
            "android:screenOrientation=”portrait”\n"
            "\n"
            "通过AndroidManifest.xml的配置实现，但是这个有极限性。\n" +
            "\n"
            "（2）setRequestedOrientation函数\n"
            "手动调用setRequestedOrientation之后，假如会引发横竖屏切换（即请求的横竖屏要求与当前的横竖屏情况不一致，就会引发切换），那么会立即调用onConfigurationChanged函数；假如不会引发横竖屏切换（请求前后一致），那么也就不会调用到onConfigurationChanged函数。\n"
            "这个手动调用setRequestedOrientation的地方也可以在Activity中的任何地方，即也可以在onConfigurationChanged中调用，但是一旦指定为横屏或竖屏完成这个变换之后，后面不论屏幕如何进行怎么翻转变化，都不会再触发横竖屏切换了，也即等同于在manifest中设置了android:screenOrientation属性为横屏或竖屏。如果要恢复为响应横竖屏随物理传感器设备变换，那么就需要手动调用类似如下代码进行恢复：\n" 
            "\n"
            "public void onViewClicked(View view) {\n"
            "    int newOrientation = 255;\n"
            "    switch (view.getId()) {\n"
            "        case R.id.rotation_0:\n"
            "            newOrientation = ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT;\n"
            "            break;\n"
            "        case R.id.rotation_1:\n"
            "            newOrientation = ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE;\n"
            "            break;\n"
            "        case R.id.rotation_2:\n"
            "            newOrientation = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;\n"
            "            break;\n"
            "        case R.id.rotation_3:\n"
            "            newOrientation = ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;\n"
            "            break;\n"
            "    }\n"
            "        setRequestedOrientation(newOrientation);\n"
            "}\n"
            "\n"
            "\n"
            "Activity进行默认旋转时候的处理，当屏幕进行旋转的时候会按照横屏的分辨率进行重绘，当然你也可以不进行任何处理难看就难看呗：），理想状态的处理就是建立两套同名的Layout，当屏幕旋转时系统会自动帮我们加载横屏的Layout。在强制重绘的时候旋转过程中可能会出现短暂黑屏（重绘是造成的）\n"
            "\n"
            "\n"
            "DEMO链接：https://github.com/shenruixiang10086/A64RotationDemo\n"
            "APP 旋转方案的请参考github链接\n"
            "\n"
            "\n"
            "\n"
            "\n"
            "（二）系统级别的旋转\n"
            "目前A64 中采用的方法就是系统级别的旋转，就是通过设置可以屏幕分别从0,90,180,270 四个角度进行旋转。一旦设置了系统在任何界面就采用当前的角度，不管设备重启，断电都不影响。在设置的界面分别有0,90,180,270四个角度的设置及一个恢复默认配置的选项。该功能实现的设备可以实现0,90,180,270四个角度的旋转。恢复出厂默认配置用于用户设置其他角度不知道如何设置默认配置的时候可以使用。该功能在系统中Mcgs-demo app中应用中屏幕旋转可以设置。\n"
</string>
    <string name="tp_calibration_documentation">"在Android4.2.2 上基本全部用的都是电容式的触摸屏了，所以Google和其他定制厂商也陆续在自己的Android版本中去掉了电阻屏校准这部分代码，所以在android4.2.2以后已经没有电阻屏校准的source code。\n"
            "\n"
            "目前A64 设备使用的是电阻屏且Android设备的版本是Android 6.0,所以默认的Android source code没有没有屏幕校准功能的，需要移植tslib的源码或者通过APP 来生产校准数据，把校准的数据提供给触屏驱动即可。\n"
            "\n"
            "\n"
            "首先生成校准用的参数，可以使用tslib生成校准参数，也可以使用校准app生成校准参数；考虑到用户的实际使用要求降低，用户可以不用学习复杂的命令及通过一些命令使用tslib来校准。所以本次校准使用APP 方式来校准，使用App 方式来校准大大降低用户的使用难度，没有任何编程基础的用户也能轻松的完成校准。生成校准参数后，以后驱动每次接收到触摸事件就会使用校准参数进行校准。校准之后每次的触摸驱动就使用校准的之后的数据。\n"
            "\n"
            "\n"
            "\n"
            "\n"
            "\n"
            "按照APP提示点击\"十字光标\"进行校准之后，就把校准的数据保存在/data/calibration里，最后把/data/calibration的校准参数传递给tsc2007驱动就完成屏幕的校准。\n"
            "\n"
            "可以使用adb shell cat /data/calibration 命令查看校准的数据，\n"
            "如：\n"
            "adb shell cat /data/calibration\n"
            "11960 473 -2863332 -305 20270 -441608 65536\n"
            "\n"
            "其中11960 473 -2863332 -305 20270 -441608 65536就是校准数据。\n"
            "\n"
            "\n"
            "\n"
            "\n"
            "校准APP简单分析如下：\n"
            "在Activity  onCreate里首先获取到了当前屏幕的宽高：\n"
            "dpy = ((WindowManager) getSystemService(WINDOW_SERVICE)).getDefaultDisplay();\n"
            "X_RES = dpy.getWidth();\n"
            "Y_RES = dpy.getHeight();\n"
            "\n"
            "\n"
            "其中X_RES， Y_RES就代表了当前屏幕的宽高。\n"
            "\n"
            "初始化要触摸点的坐标的方法：\n"
            "// TopLeft-->TopRight-->BottomRight-->BottomLeft-->Center\n"
            "private boolean initScreenPoints() {\n"
            "    cal.xfb[TOP_LEFT] = EDGE_GAP; // TopLeft\n"
            "    cal.yfb[TOP_LEFT] = EDGE_GAP;\n"
            "\n"
            "    cal.xfb[TOP_RIGHT] = X_RES - EDGE_GAP; // TopRight\n"
            "    cal.yfb[TOP_RIGHT] = EDGE_GAP;\n"
            "\n"
            "    cal.xfb[BOTTOM_RIGHT] = X_RES - EDGE_GAP; // BottomRight\n"
            "    cal.yfb[BOTTOM_RIGHT] = Y_RES - EDGE_GAP;\n"
            "\n"
            "    cal.xfb[BOTTOM_LEFT] = EDGE_GAP; // BottomLeft\n"
            "    cal.yfb[BOTTOM_LEFT] = Y_RES - EDGE_GAP;\n"
            "\n"
            "    cal.xfb[CENTER] = X_RES / 2; // Center\n"
            "    cal.yfb[CENTER] = Y_RES / 2;\n"
            "\n"
            "    Log.w(TAG, \"cal.yfb[center] =\" + cal.yfb[CENTER]);\n"
            "\n"
            "    return true;\n"
            "}\n"
            "\n"
            "\n"
            "\n"
            "初始化 5个\"十字光标\"触摸点,分别是 左上角--> 右上角 --> 右下角 --> 左下角 -->正中间，\n"
            "依次点击这5个\"十字光标\"触摸点就可以把校准参数保存在/data/calibration中\n"
            "\n"
            "接着就开始布局了，是new的一个自定义View：\n"
            "setContentView(new MyView(this));\n"
            "\n"
            "\n"
            "\n"
            "ontouchEvent方法监听手指点击事件\n"
            " public boolean onTouchEvent(MotionEvent event) {\n"
            "            float tmpx, tmpy;\n"
            "            boolean ret;\n"
            "            String proGetString=null;\n"
            "            if (screen_pos > SAMPLE_COUNTS - 1) {\n"
            "                Log.i(TAG, \"get sample ok\");\n"
            "                return true;\n"
            "            }\n"
            "\n"
            "            if (event.getAction() == MotionEvent.ACTION_UP) {\n"
            "                tmpx = event.getX();\n"
            "                tmpy = event.getY();\n"
            "                if(Math.abs(cal.xfb[screen_pos]-tmpx)>15 &amp; &amp;\n"
            "                        Math.abs(cal.yfb[screen_pos]-tmpy)>15){\n"
            "                    return false;\n"
            "                }\n"
            "\n"
            "                cal.x[screen_pos] = (int)(event.getX()*4096.0/(float)X_RES + 0.5);\n"
            "                cal.y[screen_pos] = (int)(event.getY()*4096.0/(float)Y_RES + 0.5);\n"
            "\n"
            "                if (screen_pos == 4) {\n"
            "                    ret = perform_calibration();\n"
            "                    if (ret) {\n"
            "                        saveCalibrationResult();\n"
            "                        SystemProperties.set(\"sys.config.calibrate\", \"done\");\n"
            "                        finish();\n"
            "                        return true;\n"
            "                    } else {\n"
            "                        screen_pos = 0;\n"
            "                        Log.w(TAG, \"Calibration failed\");\n"
            "                    }\n"
            "                } else {\n"
            "                    screen_pos++;\n"
            "                    drawCalibrationCross(screen_pos);\n"
            "                }\n"
            "            }\n" +
            "            return true;\n"
            "        }\n"
            "\n"
            "\n"
            "通过ontouchEvent方法监听手指点击事件把点击的事件的产生的数据通过一列的触摸校正算法及逻辑处理把数据转化成的驱动可以使用的诗句，通过saveCalibrationResult（）方法保存起来。\n"
            "\n" +
            "这样就把校准的数据保存到了 /data/calibration中，最后把/data/calibration的校准参数传递给tsc2007驱动就完成屏幕的校准。该功能在系统中Mcgs-demo app中应用中屏幕校准可以设置。\n"
            "\n"
            "\n"
            "\n"</string>
    <string name="usb_set_documentation">"Android通过两种模式，来支持各种USB外围设备和Android USB附件（硬件实现了Android的附件协议）：USB附件模式和USB主机模式。在USB附件模式下，外部 USB 硬件充当USB主机。（作为）附件的例子，包括机器人控制器、扩展插座（docking stations）、诊断和音乐设备、电子报亭（kiosks）、读卡器等其他设备。这种模式给予不具备主机功能的Android设备，与USB硬件通信的能力。Android USB附件，必须被设计为与装有Android的设备一起工作，并且必须遵循Android附件通讯协议。在USB主机模式下，装有Android的设备扮演着主机的角色。（外围）设备的例子，包括数码像机，键盘，鼠标和游戏控制器。那些适应面很广的USB设备，仍可以与Android应用交互，前提是这些Android应用可以正确的与这些设备通讯。\n" +
            "\n" +
            "图1展示了两种模式的异同。当Android设备处于主机模式时，它扮演USB主机角色并为总线供电。当Android设备处于附件模式时，被连接的USB硬件（在这种情况下是一个Android USB附件）扮演主机角色并给总线供电。Android通过两种模式，来支持各种USB外围设备和Android USB附件（硬件实现了Android的附件协议）：USB附件模式和USB主机模式。在USB附件模式下，外部 USB 硬件充当USB主机。（作为）附件的例子，包括机器人控制器、扩展插座（docking stations）、诊断和音乐设备、电子报亭（kiosks）、读卡器等其他设备。这种模式给予不具备主机功能的Android设备，与USB硬件通信的能力。Android USB附件，必须被设计为与装有Android的设备一起工作，并且必须遵循Android附件通讯协议。在USB主机模式下，装有Android的设备扮演着主机的角色。（外围）设备的例子，包括数码像机，键盘，鼠标和游戏控制器。那些适应面很广的USB设备，仍可以与Android应用交互，前提是这些Android应用可以正确的与这些设备通讯。\n" +
            "\n" +
            "图1展示了两种模式的异同。当Android设备处于主机模式时，它扮演USB主机角色并为总线供电。当Android设备处于附件模式时，被连接的USB硬件（在这种情况下是一个Android USB附件）扮演主机角色并给总线供电。Android通过两种模式，来支持各种USB外围设备和Android USB附件（硬件实现了Android的附件协议）：USB附件模式和USB主机模式。在USB附件模式下，外部 USB 硬件充当USB主机。（作为）附件的例子，包括机器人控制器、扩展插座（docking stations）、诊断和音乐设备、电子报亭（kiosks）、读卡器等其他设备。这种模式给予不具备主机功能的Android设备，与USB硬件通信的能力。Android USB附件，必须被设计为与装有Android的设备一起工作，并且必须遵循Android附件通讯协议。在USB主机模式下，装有Android的设备扮演着主机的角色。（外围）设备的例子，包括数码像机，键盘，鼠标和游戏控制器。那些适应面很广的USB设备，仍可以与Android应用交互，前提是这些Android应用可以正确的与这些设备通讯。\n" +
            "\n" +
            "图1展示了两种模式的异同。当Android设备处于主机模式时，它扮演USB主机角色并为总线供电。当Android设备处于附件模式时，被连接的USB硬件（在这种情况下是一个Android USB附件）扮演主机角色并给总线供电。Android通过两种模式，来支持各种USB外围设备和Android USB附件（硬件实现了Android的附件协议）：USB附件模式和USB主机模式。在USB附件模式下，外部 USB 硬件充当USB主机。（作为）附件的例子，包括机器人控制器、扩展插座（docking stations）、诊断和音乐设备、电子报亭（kiosks）、读卡器等其他设备。这种模式给予不具备主机功能的Android设备，与USB硬件通信的能力。Android USB附件，必须被设计为与装有Android的设备一起工作，并且必须遵循Android附件通讯协议。在USB主机模式下，装有Android的设备扮演着主机的角色。（外围）设备的例子，包括数码像机，键盘，鼠标和游戏控制器。那些适应面很广的USB设备，仍可以与Android应用交互，前提是这些Android应用可以正确的与这些设备通讯。\n" +
            "\n" +
            "图1展示了两种模式的异同。当Android设备处于主机模式时，它扮演USB主机角色并为总线供电。当Android设备处于附件模式时，被连接的USB硬件（在这种情况下是一个Android USB附件）扮演主机角色并给总线供电。"</string>

    <string name="system_common_modify">
        "1、Launcher  默认壁纸设置\n"
        "\n"
        "替换文件 platform/frameworks/base/core/core/res/drawable-swxxxdp-nodpi/default_wallpaper.jpg，\n"
        "可通过 overlay 方式将文件放在 device/vendor-name/device-name/platform/frameworks/base/core/core/res/drawable-swxxxdp-nodpi/default_wallpaper.jpg\n"
        "\n"
        "通过是上面的方式即可替换 Launcher  默认壁纸\n"
        "\n"
        "注意： 目前A64的source code是通过 overlay 方式，要替换壁纸只能通过overlay 方式。\n"
        "替换\\a64-android6.0\\android\\device\\softwinner\\tulip-p1\\overlay\\frameworks\\base\\core\\res\\res\\drawable-sw720dp-nodpi\\default_wallpaper.jpg 即可\n"
        "\n"
        "注意：default_wallpaper.jpg的大小，属性要和替换之前的一样，\n"
        "\n"
        "如果要替换的图片不一样的话，找UI同学弄一下就可以\n"
        "\n"
        "\n"
        "2、 修改启动动画\n"
        "\n"
        "将动画放入：device/vendor-name/device-name/media/bootanimation.zip\n"
        "bootanimation 格式：bootanimation.zip 包含 part0 part1 文件夹和 desc.txt 文件，part0，part1 文件夹里面放的是动画拆分的图片，格式为 png 或 jpg。desc.txt 文件内容如下：\n"
        "\n"
        "800 480 15\n"
        "p 1 0 part0\n"
        "p 0 0 part1\n"
        "\n"
        "说明：\n"
        "第一行：800 为宽度，480 为高度，15 为帧数。第二行开始 p 为标志符，接下来第二列为循环次数（０为无限循环），第三项为两次循环之间间隔的帧数，第四项为对应的目录名。播放动画时会按照图片文件名顺序自动播放。\n"
        "\n"
        "\n"
        "打包格式要求：\n"
        "windows 使用 winrar 打包，选择 ZIP 格式，压缩标准要选“储存”；linux 下，zip -0 -r ../bootanimation.zip ./* linux 命令使用-0 指定压缩等级为最低等级 stored，即只归档不压缩，否则可能由于包格式问题引起动画显示为黑屏。打包完之后修改其权限值：chmod 666 bootanimation.zip\n"
        "\n"
        "使用adb psuh  bootanimation.zip  /system/media/ \n"
        " adb reboot   即可验证效果\n"
        "\n"
        "3、 修改启动 LOGO\n"
        "\n"
        "启动 LOGO 为初始引导阶段的 LOGO。将启动 logo 放入位置：lichee/tools/pack/chips/sunxi/configs/device-name/bootlogo.bmp\n"
        "\n"
        "把需要bmp格式替换的bootlogo.bmp替换即可。\n"
        "\n"
        "\n"
        "4、Settings  设置\n"
        "4.1.  认 默认 LCD  关闭时间设置\n"
        "\n"
        "frameworks/base/packages/SettingsProvider/res/values/defaults.xml 中设置（单位为毫秒）：\n"
        "def_screen_off_timeout 设置为60000\n"
        "\n"
        "\n"
        "4.2.  默认亮度设置\n"
        "\n"
        "platform/frameworks/base/packages/SettingsProvider/res/values/defaults.xml 中设置，亮度值从 0~255 表示 0%~100%，如设置 102 则默认亮度为 40%，示例如下：\n"
        "def_screen_brightness设置为102\n"
        "\n"
        "\n"
        "4.3.  默认字体大小设置\n"
        "\n"
        "系统字体由 fontScale 来控制缩放，设置菜单中的小，普通，大，超大分别对应的 fontScale 为 0.85、1.0、1.15、1.3，修改默认字体大小可在 device/vendor-name/device-name/product-name.mk 中设置ro.font.scale 的值来设置默认的字体大小。\n"
        "如：\n"
        "PRODUCT_PROPERTY_OVERRIDES = \\\n"
        "ro.font.scale=1.0\n"
        "注：建议采用默认设置，即 ro.font.scale=1.0，过 CTS 默认必须是 1.0。\n"
        "\n"
        "4.4.  蓝牙选项设置\n"
        "\n"
        "device/vendor-name/device-name/product-name.mk，添加以下信息：\n"
        "PRODUCT_COPY_FILES = \\\n"
        "frameworks/native/data/etc/android.hardware.bluetooth.xml:system/etc/permissions/android.hardware.bluetooth.xml即可打开蓝牙选项\n"
        "\n"
        "5、常见修改\n"
        "5.1 Android App中屏蔽Home按键\n"
        "编写一个Acitivity， 屏蔽HOME按键，在onAttachedToWindow中设置TYPE_KEYGUARD_DIALOG\n"
        "比如\n"
        "public class myActivity extends Activity {\n"
        "  @Override\n"
        "    public void onAttachedToWindow()\n"
        "    {\n"
        "        super.onAttachedToWindow();\n"
        "        this.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);\n"
        "    }\n"
        "  }\n"
        "  \n"
        "  \n"
        "  \n"
        "5.2 android如何在横竖屏切换时不重新走生命周期\n"
        "Activity布局从横屏LANDSCAPE切换到PORTRAIT，会重新触发一次onCreate方法，我们可以在androidmanifest.xml中的activit元素加入这个属性android:configChanges=\"orientation|keyboardHidden\" ，同时在Activity的Java文件中重载onConfigurationChanged(Configuration  newConfig)这个方法，这样就不会在布局切换或窗口切换时重载onCreate等方法。\n"
        "\n"
        "\n"
        "\n"
        "5.3通过配置文件调节触摸提示音音量\n"
        "触摸提示音有两种接口，一种为指定音量；另一种为使用默认音量。\n"
        "文件framework/base/core/res/res/values/config.xml中config_soundEffectVolumeDb对默认触摸提示音音量有作用。可修改为-6~0之间的值，0为最大音量。\n"
        "\n"
        "\n"
        "5.4  默认不要锁屏，设置-安全--屏幕锁定 (无)\n"
        "overlay/frameworks/base/packages/SettingsProvider/res/values/defaults.xml\n"
        "def_lockscreen_disabled设置为true\n"
        "\n"
        "\n"
        "5.5. 修改默认(Settting.apk 中选项默认值一般存在于 frameworks\\base\\packages\\SettingsProvider\\res\\values\\defaults.xml)\n"
        "1. 默认勾选 未知来源\n"
        "<bool name="def_install_non_market_apps">false</bool> \n"
    "\n"
    "5.6. 默认铃声, 通知, 闹钟 音乐\n"
    "可以在system.prop 分别配置\n"
    "\n"
    "ro.config.ringtone=Playa.ogg （默认铃声设置，文件在/system/media/audio/ringtones 把喜欢的铃声放这里，比如123.MP3放入ringtones文件夹中，这里代码改为ro.config.ringtone=123.mp3）\n"
    "\n"
    "ro.config.notification_sound=regulus.ogg （默认提示音，文件在/system/media/audio/notifications 修改方法同上）\n"
    "\n"
    "ro.config.alarm_alert=Alarm_Beep_03.ogg （默认闹铃，文件在/system/media/audio/alarms 修改方法同上）\n"
    "\n"
    "5.7. 壁纸不跟随滑动\n"
    "packages/apps/Launcher2/./src/com/android/launcher2/Workspace.java  大概 875行\n"
    "private float wallpaperOffsetForCurrentScroll() \n"
    "修改 wallpaperOffsetForCurrentScroll 的返回值。 改成 return  0.5f; \n"
    "\n"
    "\n"
    "5.8背光亮度,静音等默认值修改 \n"
    "修改\\frameworks\\base\\packages\\SettingsProvider\\res\\values\\defaults.xml中的默认值即可"</string>

    <string name="rotation_default">屏幕旋转默认角度</string>
    <string name="rotation_90">屏幕旋转90度</string>
    <string name="rotation_180">屏幕旋转180度</string>
    <string name="rotation_270">屏幕旋转270度</string>
    <string name="btn_restore">恢复出厂默认配置</string>
    <string name="rotation_settings_title">"点击开始进行屏幕旋转设置"</string>
    <string name="btn_restore_message">是否恢复出厂默认配置?</string>
    <string name="rotation_summry">屏幕旋转应用说明：由于该设备没有Sensors没有自动旋转的功能，该功能实现的设备可以实现0,90,180,270四个角度的旋转。恢复出厂默认配置，还原出厂时的默认角度</string>
    <string name="ethernet_on">以太网</string>


    <string name="ethernet_ip_settings_invalid_ip">"请填写正确的格式"</string>
    <string name="save_satic_ethernet">"保存"</string>
    <string name="eth_ip_settings_please_complete_settings">"网络信息不完整，请填写完整"</string>
    <string name="enthernet_static">"使用静态设置"</string>
    <string name="enthernet_ip_address">"IP地址"</string>
    <string name="enthernet_gateway">"网关"</string>
    <string name="enthernet_netmask">"子网掩码"</string>
    <string name="enthernet_dns1">"域名1"</string>
    <string name="enthernet_dns2">"域名2"</string>
    <string name="ethernet_quick_toggle_title">"以太网"</string>
    <string name="open_ethernet">"打开以太网"</string>
    <string name="ethernet_static_ip_settings_title">"配置以太网"</string>
    <string name="ethernet_settings">"以太网"</string>
    <string name="ethernet_settings_title">"以太网"</string>
    <string name="calibrate_settings_title">"点击开始进行触屏校准"</string>
    <string name="app_start_error">"未检测到触屏校准程序"</string>
    <string name="serialport_documentation">"串口文档"</string>


    <string name="ethernet_settings_btn">"点击开始进行以太网配置"</string>
    <string name="ethernet_settings_summry">"以太网的功能是允许设备提供硬件接口通过插入网线的形式访问互联网的功能。接入网线之后，设备可以动态的获取IP，DNS，Gateway等一系列网络属性，手动配置设备的网络属性，使用静态配置参数，通过配置eth0网口的IP，DNS，Gateway三个参数，实现上网功能。"</string>

    <string name="serialport_settings_btn">"点击开始进行串口配置"</string>
    <string name="serialport_settings_summry">"串口通信"</string>
    <string name="calibrate_settings_summry">"(1)首先生成校准用的参数，可以适用tslib生成校准参数，也可以使用校准app生成；使用校准app进行校准对使用者要求比较低，使用者可以不用学习复杂的命令；从用户的角度考虑使用app方式\n"
            "\n"
            "(2)生成校准参数后，以后驱动每次接收到触摸事件就会使用校准参数进行校准"</string>

    <string name="mcgs_usb_mode">"USB模式配置"</string>
    <string name="mcgs_usb_mode_default">0</string>
    <string name="mcgs_usb_mode_set">设置usb当前模式</string>


    <string name="mcgs_lcd_set">"背光设置"</string>
    <string name="mcgs_lcd_set_status">"LCD显示背光"</string>
    <string name="mcgs_lcd_set_on">"LCD显示背光打开"</string>
    <string name="mcgs_lcd_set_off">"LCD显示背光关闭"</string>
    <string name="mcgs_lcd_set_brightness">"设置背光亮度[1:100]"</string>

    <string name="mcgs_bee_set">"蜂鸣控制"</string>
    <string name="mcgs_bee_set_time">"设置蜂鸣控制时间(ms)"</string>

    <string name="mcgs_rtc_set">"RTC 配置"</string>
    <string name="mcgs_rtc_set_time">"设置RTC时间"</string>



    <string name="mcgs_lct_set_default">"50"</string>
    <string name="mcgs_rtc_set_default">"0"</string>
    <string name="mcgs_bee_set_default">"10"</string>




</resources>
