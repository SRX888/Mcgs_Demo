<resources>
    <string name="app_name">Mcgs</string>
    <string name="title_docment">文档</string>
    <string name="title_application">应用</string>
    <string name="title_settings">设置</string>


    <string name="app_rotation_title">屏幕旋转</string>


    <string name="ethernet_documentation">"通过比较网桥优先级选取根网桥(给定广播域内只有一个根网桥)。\n" +
            "\n" +
            "·其余的非根网桥只有一个通向根交换机的端口称为根端口。\n" +
            "\n" +
            "·每个网段只有一个转发端口。\n" +
            "\n" +
            "·根交换机所有的连接端口均为转发端口。\n" +
            "\n" +
            "注意:生成树协议在交换机上一般是默认开启的,不经人工干预即可正常工作。但这种自动生成的方案可能导致数据传输的路径并非最优化。因此,可以通过人工设置网桥优先级的方法影响生成树的生成结果。\n" +
            "\n" +
            "生成树的状态:\n" +
            "\n" +
            "运行生成树协议的交换机上的端口,总是处于下面四个状态中的一个。在正常操作期间,端口处于转发或阻塞状态。当设备识别网络拓扑结构变化时,交换机自动进行状态转换,在这期间端口暂时处于监听和学习状态。\n" +
            "\n" +
            "阻塞:所有端口以阻塞状态启动以防止回路。由生成树确定哪个端口转换到转发状态,处于阻塞状态的端口不转发数据但可接受BPDU。\n" +
            "\n" +
            "监听:不转发,检测BPDU,(临时状态)。\n" +
            "\n" +
            "学习:不转发,学习MAC地址表(临时状态)。\n" +
            "\n" +
            "转发:端口能转送和接受数据。\n" +
            "\n" +
            "小知识:实际上,在真正使用交换机时还可能出现一种特殊的端口状态-Disabl e状态。这是由于端口故障或由于错误的交换机配置而导致数据冲突造成的死锁状态。如果并非是端口故障的原因,我们可以通过交换机重启来解决这一问题。\n" +
            "\n" +
            "生成树的重计算:\n" +
            "\n" +
            "当网络的拓扑结构发生改变时,生成树协议重新计算,以生成新的生成树结构。当所有交换机的端口状态变为转发或阻塞时,意味着重新计算 完毕。这种状态称为会聚(Convergence)。\n" +
            "当网络的拓扑结构发生改变时,生成树协议重新计算,以生成新的生成树结构。当所有交换机的端口状态变为转发或阻塞时,意味着重新计算完毕。这种状态称为会聚(Convergence)。\n" +
            "\n" +
            "注意:在网络拓扑结构改变期间,设备直到生成树会聚才能进行通信,这可能会对某些应用产生影响,因此一般认为可以使生成树运行良好的交换网络,不应该超过七层。此外可以通过一些特殊的交换机技术加快会聚的时间。\n" +
            "\n" +
            "网桥\n" +
            "\n" +
            "网桥概述:\n" +
            "\n" +
            "依据帧地址进行转发的二层网络设备,可将数个局域网网段连接在一起。网桥可连接相同介质的网段也可访问不同介质的网段。网桥的主要作用是分割和减少冲突。它的工作原理同交换机类似,也是通过MAC地址表进行转发。因此,网桥同交换机没有本质的区别。在某些情况下,我们可以认为网桥就是交换机。\n" +
            "\n" +
            "路由器的简单介绍\n" +
            "\n" +
            "什么是路由器:\n" +
            "\n" +
            "路由器是使用一种或者更多度量因素的网络设备,它决定网络通信能够通过的最佳路径。路由器依据网络层信息将数据包从一个网络前向转发到另一个网络。\n" +
            "\n" +
            "路由器的功能:"</string>
    <string name="serialport_documentation">"说到串口开发，不得不先明确一下以下概念。\n" +
            "\n" +
            "接口的定义：\n" +
            "\n" +
            "接口泛指实体把自己提供给外界的一种抽象化物（可以为另一实体），用以由内部操作分离出外部沟通方法，使其能被修改内部而不影响外界其他实体与其交互的方式。\n" +
            "串行接口的定义：\n" +
            "\n" +
            "串行接口简称 串口，也称 串行通信接口 或 串行通讯接口（通常指COM接口）。是指数据一位一位地顺序传送，其特点是通信线路简单，只要一对传输线就可以实现双向通信，从而大大降低了成本，特别适用于远距离通信，但传送速度较慢。\n" +
            "串口通信的定义：\n" +
            "\n" +
            "串口按位（bit）发送和接收字节。\n" +
            "串口通讯的定义：\n" +
            "\n" +
            "串口通讯(Serial Communication)， 是指外设和计算机间，通过数据信号线 、地线、控制线等，按位进行传输数据的一种通讯方式。一条信息的各位数据被逐位按顺序传送的通讯方式称为串行通讯。"</string>
    <string name="rotation_documentation">"Android 屏幕旋转的机制默认情况下通过重力感应器（G-sensor）来实现的，带有G-sensor的Android设备上可通过API获取到设备的运动加速度，应用程序通过一些假设和算法运算，可以从加速度计算出设备的方向，通过计算出来的值。PhoneWindownManager 通过注册一个ContentObserver来监听用户设置的变化，当用户设置变化后调用updateSettings（）函数，做设置变化的更新和做相应的动作。WindowManagerService完成屏幕旋转的功能，首先更新屏幕方向，然后具体实施屏幕旋转，最后通知AMS configuration变更。\n"
            "\n"
            "上面的所说的都是基于Android设备的具有G-sensor的模块，通过监听G-sensor数据的变化实现屏幕的旋转。但是对于没有G-sensor的模块的设备或者通过想要通过按键来触发屏幕的旋转，怎么实现呢？\n"
            "\n"
            "不管是通过G-sensor设备还是通过按键或者其他的方式来触发屏幕旋转的流程都一样的，只是提供数据的方式有区别而已。\n"
            " \n"
            "\n"
            "\n"
            "其实现机制为：当Configuration改变后，ActivityManagerService将会发送\"配置改变\"的广播，会要求ActivityThread重新启动当前focus的Activity，这是默认情况。如果想很好地支持屏幕旋转，则建议在res中建立layout-land和layout-port两个文件夹，把横屏和竖屏的布局文件放入对应的layout文件夹中。如果不申明android:configChanges=\"\"，按照Activity的生命周期，都会去执行一次onCreate()方法，而onCreate()方法通常会在显示之前做一些初始化工作。这样就有可能造成重复的初始化，必然降低程序效率，而且更有可能因为重复的初始化而导致数据的丢失。\n"
            "\n"
            "\n"
            "\n"
            "目前的A64 Android 设备就是没有G-sensor的模块，具体的实现的就是通过按键或者一些操作模拟G-sensor数据，再把数据传给WindowManagerService，最后通过WindowManagerService判断的接收的数据控制屏幕旋转。\n"
            "\n"
            "\n"
            "现在从Android APP（单个应用的旋转，只有在APP界面内旋转）和系统级别的旋转（一旦选择，不管重启还是其他行为都保持该旋转的模式），分别从0,90,180,270 四个角度进行旋转。\n"
            "\n"
            "\n"
            "（一）APP 四个角度的旋转：\n"
            "在APP界面通过按键来实现APP的旋转\n"
            "有2种方式控制屏幕方向：\n"
            "（1）修改AndroidManifest.xml\n"
            "1 在AndroidManifest.xml的activity中加入:\n"
            "横屏：\n"
            "android:screenOrientation=”landscape”\n"
            "竖屏：\n"
            "android:screenOrientation=”portrait”\n"
            "\n"
            "通过AndroidManifest.xml的配置实现，但是这个有极限性。\n" +
            "\n"
            "（2）setRequestedOrientation函数\n"
            "手动调用setRequestedOrientation之后，假如会引发横竖屏切换（即请求的横竖屏要求与当前的横竖屏情况不一致，就会引发切换），那么会立即调用onConfigurationChanged函数；假如不会引发横竖屏切换（请求前后一致），那么也就不会调用到onConfigurationChanged函数。\n"
            "这个手动调用setRequestedOrientation的地方也可以在Activity中的任何地方，即也可以在onConfigurationChanged中调用，但是一旦指定为横屏或竖屏完成这个变换之后，后面不论屏幕如何进行怎么翻转变化，都不会再触发横竖屏切换了，也即等同于在manifest中设置了android:screenOrientation属性为横屏或竖屏。如果要恢复为响应横竖屏随物理传感器设备变换，那么就需要手动调用类似如下代码进行恢复：\n" 
            "\n"
            "public void onViewClicked(View view) {\n"
            "    int newOrientation = 255;\n"
            "    switch (view.getId()) {\n"
            "        case R.id.rotation_0:\n"
            "            newOrientation = ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT;\n"
            "            break;\n"
            "        case R.id.rotation_1:\n"
            "            newOrientation = ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE;\n"
            "            break;\n"
            "        case R.id.rotation_2:\n"
            "            newOrientation = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;\n"
            "            break;\n"
            "        case R.id.rotation_3:\n"
            "            newOrientation = ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;\n"
            "            break;\n"
            "    }\n"
            "        setRequestedOrientation(newOrientation);\n"
            "}\n"
            "\n"
            "\n"
            "Activity进行默认旋转时候的处理，当屏幕进行旋转的时候会按照横屏的分辨率进行重绘，当然你也可以不进行任何处理难看就难看呗：），理想状态的处理就是建立两套同名的Layout，当屏幕旋转时系统会自动帮我们加载横屏的Layout。在强制重绘的时候旋转过程中可能会出现短暂黑屏（重绘是造成的）\n"
            "\n"
            "\n"
            "DEMO链接：https://github.com/shenruixiang10086/A64RotationDemo\n"
            "APP 旋转方案的请参考github链接\n"
            "\n"
            "\n"
            "\n"
            "\n"
            "（二）系统级别的旋转\n"
            "目前A64 中采用的方法就是系统级别的旋转，就是通过设置可以屏幕分别从0,90,180,270 四个角度进行旋转。一旦设置了系统在任何界面就采用当前的角度，不管设备重启，断电都不影响。在设置的界面分别有0,90,180,270四个角度的设置及一个恢复默认配置的选项。该功能实现的设备可以实现0,90,180,270四个角度的旋转。恢复出厂默认配置用于用户设置其他角度不知道如何设置默认配置的时候可以使用。该功能在系统中Mcgs-demo app中应用中屏幕旋转可以设置。\n"
</string>
    <string name="tp_calibration_documentation">"首先了解一下tslib的运行原理，tslib的运行分成两部分\n" +
            "(1)校验\n" +
            "在LCD固定坐标位置依次显示出5个坐标让用户触摸，把LCD坐标和用户触摸时驱动屏驱动底层的坐标总共5组值保存起来\n" +
            "运行tslib库的算法对其进行运算，得出校准用7个值\n" +
            "\n" +
            "(2)校准\n" +
            "每次触摸屏驱动读取到硬件坐标时应用校准用的7个值对该坐标进行一次运算，然后将运算后的坐标作为正常坐标即可。\n" +
            "按照上面的原理，\n" +
            "(1)我们先修改内核部分，我的平台用的触摸屏幕驱动是tsc2007，驱动文件为内核/drivers/input/touchscreen\n" +
            "目录下的tsc2007.c和ts_linear.c\n" +
            "其中，ts_linear.c中定义的是校准模块，该模块在proc文件系统中建立了7个文件，用来存放校准用的7个点，7的点的默认值\n" +
            "为1,0,0,0,1,0,1，对应的目标平台文件系统的位置为/proc/sys/dev/ts_device目录下a0,a1,a2,a3,a4,a5,a6等7个文件\n" +
            "此模块中还定义了一个校准函数ts_linear_scale，此函数的主要内容是读取a0,a1,a2,a3,a4,a5,a6等7个文件中的值作为7个\n" +
            "校准值与传入的触摸平坐标值进行运算，返回运算结果"</string>
    <string name="usb_set_documentation">"Android通过两种模式，来支持各种USB外围设备和Android USB附件（硬件实现了Android的附件协议）：USB附件模式和USB主机模式。在USB附件模式下，外部 USB 硬件充当USB主机。（作为）附件的例子，包括机器人控制器、扩展插座（docking stations）、诊断和音乐设备、电子报亭（kiosks）、读卡器等其他设备。这种模式给予不具备主机功能的Android设备，与USB硬件通信的能力。Android USB附件，必须被设计为与装有Android的设备一起工作，并且必须遵循Android附件通讯协议。在USB主机模式下，装有Android的设备扮演着主机的角色。（外围）设备的例子，包括数码像机，键盘，鼠标和游戏控制器。那些适应面很广的USB设备，仍可以与Android应用交互，前提是这些Android应用可以正确的与这些设备通讯。\n" +
            "\n" +
            "图1展示了两种模式的异同。当Android设备处于主机模式时，它扮演USB主机角色并为总线供电。当Android设备处于附件模式时，被连接的USB硬件（在这种情况下是一个Android USB附件）扮演主机角色并给总线供电。Android通过两种模式，来支持各种USB外围设备和Android USB附件（硬件实现了Android的附件协议）：USB附件模式和USB主机模式。在USB附件模式下，外部 USB 硬件充当USB主机。（作为）附件的例子，包括机器人控制器、扩展插座（docking stations）、诊断和音乐设备、电子报亭（kiosks）、读卡器等其他设备。这种模式给予不具备主机功能的Android设备，与USB硬件通信的能力。Android USB附件，必须被设计为与装有Android的设备一起工作，并且必须遵循Android附件通讯协议。在USB主机模式下，装有Android的设备扮演着主机的角色。（外围）设备的例子，包括数码像机，键盘，鼠标和游戏控制器。那些适应面很广的USB设备，仍可以与Android应用交互，前提是这些Android应用可以正确的与这些设备通讯。\n" +
            "\n" +
            "图1展示了两种模式的异同。当Android设备处于主机模式时，它扮演USB主机角色并为总线供电。当Android设备处于附件模式时，被连接的USB硬件（在这种情况下是一个Android USB附件）扮演主机角色并给总线供电。Android通过两种模式，来支持各种USB外围设备和Android USB附件（硬件实现了Android的附件协议）：USB附件模式和USB主机模式。在USB附件模式下，外部 USB 硬件充当USB主机。（作为）附件的例子，包括机器人控制器、扩展插座（docking stations）、诊断和音乐设备、电子报亭（kiosks）、读卡器等其他设备。这种模式给予不具备主机功能的Android设备，与USB硬件通信的能力。Android USB附件，必须被设计为与装有Android的设备一起工作，并且必须遵循Android附件通讯协议。在USB主机模式下，装有Android的设备扮演着主机的角色。（外围）设备的例子，包括数码像机，键盘，鼠标和游戏控制器。那些适应面很广的USB设备，仍可以与Android应用交互，前提是这些Android应用可以正确的与这些设备通讯。\n" +
            "\n" +
            "图1展示了两种模式的异同。当Android设备处于主机模式时，它扮演USB主机角色并为总线供电。当Android设备处于附件模式时，被连接的USB硬件（在这种情况下是一个Android USB附件）扮演主机角色并给总线供电。Android通过两种模式，来支持各种USB外围设备和Android USB附件（硬件实现了Android的附件协议）：USB附件模式和USB主机模式。在USB附件模式下，外部 USB 硬件充当USB主机。（作为）附件的例子，包括机器人控制器、扩展插座（docking stations）、诊断和音乐设备、电子报亭（kiosks）、读卡器等其他设备。这种模式给予不具备主机功能的Android设备，与USB硬件通信的能力。Android USB附件，必须被设计为与装有Android的设备一起工作，并且必须遵循Android附件通讯协议。在USB主机模式下，装有Android的设备扮演着主机的角色。（外围）设备的例子，包括数码像机，键盘，鼠标和游戏控制器。那些适应面很广的USB设备，仍可以与Android应用交互，前提是这些Android应用可以正确的与这些设备通讯。\n" +
            "\n" +
            "图1展示了两种模式的异同。当Android设备处于主机模式时，它扮演USB主机角色并为总线供电。当Android设备处于附件模式时，被连接的USB硬件（在这种情况下是一个Android USB附件）扮演主机角色并给总线供电。"</string>
    <string name="rotation_default">屏幕旋转默认角度</string>
    <string name="rotation_90">屏幕旋转90度</string>
    <string name="rotation_180">屏幕旋转180度</string>
    <string name="rotation_270">屏幕旋转270度</string>
    <string name="btn_restore">恢复出厂默认配置</string>
    <string name="btn_restore_message">是否恢复出厂默认配置?</string>
    <string name="rotation_summry">屏幕旋转应用说明：由于该设备没有Sensors没有自动旋转的功能，该功能实现的设备可以实现0,90,180,270四个角度的旋转。恢复出厂默认配置，还原出厂时的默认角度</string>
    <string name="ethernet_on">以太网</string>


    <string name="ethernet_ip_settings_invalid_ip">"请填写正确的格式"</string>
    <string name="save_satic_ethernet">"保存"</string>
    <string name="eth_ip_settings_please_complete_settings">"网络信息不完整，请填写完整"</string>
    <string name="enthernet_static">"使用静态设置"</string>
    <string name="enthernet_ip_address">"IP地址"</string>
    <string name="enthernet_gateway">"网关"</string>
    <string name="enthernet_netmask">"子网掩码"</string>
    <string name="enthernet_dns1">"域名1"</string>
    <string name="enthernet_dns2">"域名2"</string>
    <string name="ethernet_quick_toggle_title">"以太网"</string>
    <string name="open_ethernet">"打开以太网"</string>
    <string name="ethernet_static_ip_settings_title">"配置以太网"</string>
    <string name="ethernet_settings">"以太网"</string>
    <string name="ethernet_settings_title">"以太网"</string>
    <string name="calibrate_settings_title">"点击开始进行触屏校准"</string>
    <string name="app_start_error">"未检测到触屏校准程序"</string>

    <string name="ethernet_settings_btn">"点击开始进行以太网配置"</string>


    <string name="calibrate_settings_summry">"(1)首先生成校准用的参数，可以适用tslib生成校准参数，也可以使用校准app生成；使用校准app进行校准对使用者要求比较低，使用者可以不用学习复杂的命令；从用户的角度考虑使用app方式\n"
            "\n"
            "(2)生成校准参数后，以后驱动每次接收到触摸事件就会使用校准参数进行校准"</string>




</resources>
