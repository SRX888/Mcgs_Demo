<resources>
    <string name="app_name">Mcgs</string>
    <string name="title_docment">文档</string>
    <string name="title_application">应用</string>
    <string name="title_settings">设置</string>


    <string name="app_rotation_title">屏幕旋转</string>


    <string name="ethernet_documentation">"通过比较网桥优先级选取根网桥(给定广播域内只有一个根网桥)。\n" +
            "\n" +
            "·其余的非根网桥只有一个通向根交换机的端口称为根端口。\n" +
            "\n" +
            "·每个网段只有一个转发端口。\n" +
            "\n" +
            "·根交换机所有的连接端口均为转发端口。\n" +
            "\n" +
            "注意:生成树协议在交换机上一般是默认开启的,不经人工干预即可正常工作。但这种自动生成的方案可能导致数据传输的路径并非最优化。因此,可以通过人工设置网桥优先级的方法影响生成树的生成结果。\n" +
            "\n" +
            "生成树的状态:\n" +
            "\n" +
            "运行生成树协议的交换机上的端口,总是处于下面四个状态中的一个。在正常操作期间,端口处于转发或阻塞状态。当设备识别网络拓扑结构变化时,交换机自动进行状态转换,在这期间端口暂时处于监听和学习状态。\n" +
            "\n" +
            "阻塞:所有端口以阻塞状态启动以防止回路。由生成树确定哪个端口转换到转发状态,处于阻塞状态的端口不转发数据但可接受BPDU。\n" +
            "\n" +
            "监听:不转发,检测BPDU,(临时状态)。\n" +
            "\n" +
            "学习:不转发,学习MAC地址表(临时状态)。\n" +
            "\n" +
            "转发:端口能转送和接受数据。\n" +
            "\n" +
            "小知识:实际上,在真正使用交换机时还可能出现一种特殊的端口状态-Disabl e状态。这是由于端口故障或由于错误的交换机配置而导致数据冲突造成的死锁状态。如果并非是端口故障的原因,我们可以通过交换机重启来解决这一问题。\n" +
            "\n" +
            "生成树的重计算:\n" +
            "\n" +
            "当网络的拓扑结构发生改变时,生成树协议重新计算,以生成新的生成树结构。当所有交换机的端口状态变为转发或阻塞时,意味着重新计算 完毕。这种状态称为会聚(Convergence)。\n" +
            "当网络的拓扑结构发生改变时,生成树协议重新计算,以生成新的生成树结构。当所有交换机的端口状态变为转发或阻塞时,意味着重新计算完毕。这种状态称为会聚(Convergence)。\n" +
            "\n" +
            "注意:在网络拓扑结构改变期间,设备直到生成树会聚才能进行通信,这可能会对某些应用产生影响,因此一般认为可以使生成树运行良好的交换网络,不应该超过七层。此外可以通过一些特殊的交换机技术加快会聚的时间。\n" +
            "\n" +
            "网桥\n" +
            "\n" +
            "网桥概述:\n" +
            "\n" +
            "依据帧地址进行转发的二层网络设备,可将数个局域网网段连接在一起。网桥可连接相同介质的网段也可访问不同介质的网段。网桥的主要作用是分割和减少冲突。它的工作原理同交换机类似,也是通过MAC地址表进行转发。因此,网桥同交换机没有本质的区别。在某些情况下,我们可以认为网桥就是交换机。\n" +
            "\n" +
            "路由器的简单介绍\n" +
            "\n" +
            "什么是路由器:\n" +
            "\n" +
            "路由器是使用一种或者更多度量因素的网络设备,它决定网络通信能够通过的最佳路径。路由器依据网络层信息将数据包从一个网络前向转发到另一个网络。\n" +
            "\n" +
            "路由器的功能:"</string>
    <string name="serialport_documentation">"说到串口开发，不得不先明确一下以下概念。\n" +
            "\n" +
            "接口的定义：\n" +
            "\n" +
            "接口泛指实体把自己提供给外界的一种抽象化物（可以为另一实体），用以由内部操作分离出外部沟通方法，使其能被修改内部而不影响外界其他实体与其交互的方式。\n" +
            "串行接口的定义：\n" +
            "\n" +
            "串行接口简称 串口，也称 串行通信接口 或 串行通讯接口（通常指COM接口）。是指数据一位一位地顺序传送，其特点是通信线路简单，只要一对传输线就可以实现双向通信，从而大大降低了成本，特别适用于远距离通信，但传送速度较慢。\n" +
            "串口通信的定义：\n" +
            "\n" +
            "串口按位（bit）发送和接收字节。\n" +
            "串口通讯的定义：\n" +
            "\n" +
            "串口通讯(Serial Communication)， 是指外设和计算机间，通过数据信号线 、地线、控制线等，按位进行传输数据的一种通讯方式。一条信息的各位数据被逐位按顺序传送的通讯方式称为串行通讯。"</string>
    <string name="rotation_documentation">""在介绍之前，我们需要先了解默认情况下android屏幕旋转的机制：\n" +
            "\n" +
            "默认情况下，当用户手机的重力感应器打开后，旋转屏幕方向，会导致当前activity发生onDestroy-> onCreate，这样会重新构造当前activity和界面布局，如果在Camera界面，则表现为卡顿或者黑屏一段时间。如果是在横竖屏UI设计方面，那么想很好地支持屏幕旋转，则建议在res中建立layout-land和layout-port两个文件夹，把横屏和竖屏的布局文件分别放入对应的layout文件夹中。\n" +
            "\n" +
            "了解了这些以后，我们对android的屏幕旋转方法进行如下总结：\n" +
            "\n" +
            "1. AndroidManifest.xml设置\n" +
            "\n" +
            "如果单单想设置横屏或者竖屏，那么只需要添加横竖屏代码：\n" +
            "\n" +
            "android:screenOrientation=\"landscape\"横屏设置;\n" +
            "android:screenOrientation=\"portrait\"竖屏设置;\n" +
            "这种方法的优点：即使屏幕旋转，Activity也不会重新onCreate。\n" +
            "\n" +
            "缺点：屏幕只有一个方向。\n" +
            "\n" +
            "2. 代码动态设置\n" +
            "\n" +
            "如果你需要动态改变横竖屏设置，那么，只需要在代码中调用setRequestedOrientation()函数：\n" +
            "\n" +
            "setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);\n" +
            "//横屏设置\n" +
            "setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);\n" +
            "//竖屏设置\n" +
            "setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);\n" +
            "//默认设置\n" +
            "这种方法优点：可以随意动态设置，满足我们人为改变横竖屏的要求，同时满足横竖屏UI不同的设计需求；\n" +
            "\n" +
            "缺点：如果改变设置，那么，Activity会被销毁，重新构建，即重新onCreate；\n" +
            "\n" +
            "3. 重写onConfigurationChanged""</string>
    <string name="tp_calibration_documentation">"首先了解一下tslib的运行原理，tslib的运行分成两部分\n" +
            "(1)校验\n" +
            "在LCD固定坐标位置依次显示出5个坐标让用户触摸，把LCD坐标和用户触摸时驱动屏驱动底层的坐标总共5组值保存起来\n" +
            "运行tslib库的算法对其进行运算，得出校准用7个值\n" +
            "\n" +
            "(2)校准\n" +
            "每次触摸屏驱动读取到硬件坐标时应用校准用的7个值对该坐标进行一次运算，然后将运算后的坐标作为正常坐标即可。\n" +
            "按照上面的原理，\n" +
            "(1)我们先修改内核部分，我的平台用的触摸屏幕驱动是tsc2007，驱动文件为内核/drivers/input/touchscreen\n" +
            "目录下的tsc2007.c和ts_linear.c\n" +
            "其中，ts_linear.c中定义的是校准模块，该模块在proc文件系统中建立了7个文件，用来存放校准用的7个点，7的点的默认值\n" +
            "为1,0,0,0,1,0,1，对应的目标平台文件系统的位置为/proc/sys/dev/ts_device目录下a0,a1,a2,a3,a4,a5,a6等7个文件\n" +
            "此模块中还定义了一个校准函数ts_linear_scale，此函数的主要内容是读取a0,a1,a2,a3,a4,a5,a6等7个文件中的值作为7个\n" +
            "校准值与传入的触摸平坐标值进行运算，返回运算结果"</string>
    <string name="usb_set_documentation">"Android通过两种模式，来支持各种USB外围设备和Android USB附件（硬件实现了Android的附件协议）：USB附件模式和USB主机模式。在USB附件模式下，外部 USB 硬件充当USB主机。（作为）附件的例子，包括机器人控制器、扩展插座（docking stations）、诊断和音乐设备、电子报亭（kiosks）、读卡器等其他设备。这种模式给予不具备主机功能的Android设备，与USB硬件通信的能力。Android USB附件，必须被设计为与装有Android的设备一起工作，并且必须遵循Android附件通讯协议。在USB主机模式下，装有Android的设备扮演着主机的角色。（外围）设备的例子，包括数码像机，键盘，鼠标和游戏控制器。那些适应面很广的USB设备，仍可以与Android应用交互，前提是这些Android应用可以正确的与这些设备通讯。\n" +
            "\n" +
            "图1展示了两种模式的异同。当Android设备处于主机模式时，它扮演USB主机角色并为总线供电。当Android设备处于附件模式时，被连接的USB硬件（在这种情况下是一个Android USB附件）扮演主机角色并给总线供电。Android通过两种模式，来支持各种USB外围设备和Android USB附件（硬件实现了Android的附件协议）：USB附件模式和USB主机模式。在USB附件模式下，外部 USB 硬件充当USB主机。（作为）附件的例子，包括机器人控制器、扩展插座（docking stations）、诊断和音乐设备、电子报亭（kiosks）、读卡器等其他设备。这种模式给予不具备主机功能的Android设备，与USB硬件通信的能力。Android USB附件，必须被设计为与装有Android的设备一起工作，并且必须遵循Android附件通讯协议。在USB主机模式下，装有Android的设备扮演着主机的角色。（外围）设备的例子，包括数码像机，键盘，鼠标和游戏控制器。那些适应面很广的USB设备，仍可以与Android应用交互，前提是这些Android应用可以正确的与这些设备通讯。\n" +
            "\n" +
            "图1展示了两种模式的异同。当Android设备处于主机模式时，它扮演USB主机角色并为总线供电。当Android设备处于附件模式时，被连接的USB硬件（在这种情况下是一个Android USB附件）扮演主机角色并给总线供电。Android通过两种模式，来支持各种USB外围设备和Android USB附件（硬件实现了Android的附件协议）：USB附件模式和USB主机模式。在USB附件模式下，外部 USB 硬件充当USB主机。（作为）附件的例子，包括机器人控制器、扩展插座（docking stations）、诊断和音乐设备、电子报亭（kiosks）、读卡器等其他设备。这种模式给予不具备主机功能的Android设备，与USB硬件通信的能力。Android USB附件，必须被设计为与装有Android的设备一起工作，并且必须遵循Android附件通讯协议。在USB主机模式下，装有Android的设备扮演着主机的角色。（外围）设备的例子，包括数码像机，键盘，鼠标和游戏控制器。那些适应面很广的USB设备，仍可以与Android应用交互，前提是这些Android应用可以正确的与这些设备通讯。\n" +
            "\n" +
            "图1展示了两种模式的异同。当Android设备处于主机模式时，它扮演USB主机角色并为总线供电。当Android设备处于附件模式时，被连接的USB硬件（在这种情况下是一个Android USB附件）扮演主机角色并给总线供电。Android通过两种模式，来支持各种USB外围设备和Android USB附件（硬件实现了Android的附件协议）：USB附件模式和USB主机模式。在USB附件模式下，外部 USB 硬件充当USB主机。（作为）附件的例子，包括机器人控制器、扩展插座（docking stations）、诊断和音乐设备、电子报亭（kiosks）、读卡器等其他设备。这种模式给予不具备主机功能的Android设备，与USB硬件通信的能力。Android USB附件，必须被设计为与装有Android的设备一起工作，并且必须遵循Android附件通讯协议。在USB主机模式下，装有Android的设备扮演着主机的角色。（外围）设备的例子，包括数码像机，键盘，鼠标和游戏控制器。那些适应面很广的USB设备，仍可以与Android应用交互，前提是这些Android应用可以正确的与这些设备通讯。\n" +
            "\n" +
            "图1展示了两种模式的异同。当Android设备处于主机模式时，它扮演USB主机角色并为总线供电。当Android设备处于附件模式时，被连接的USB硬件（在这种情况下是一个Android USB附件）扮演主机角色并给总线供电。"</string>
    <string name="rotation_default">屏幕旋转默认角度</string>
    <string name="rotation_90">屏幕旋转90度</string>
    <string name="rotation_180">屏幕旋转180度</string>
    <string name="rotation_270">屏幕旋转270度</string>
    <string name="btn_restore">恢复出厂默认配置</string>
    <string name="btn_restore_message">是否恢复出厂默认配置?</string>
    <string name="rotation_summry">屏幕旋转应用说明：由于该设备没有Sensors没有自动旋转的功能，该功能实现的设备可以实现0,90,180,270四个角度的旋转。恢复出厂默认配置，还原出厂时的默认角度</string>
    <string name="ethernet_on">以太网</string>


    <string name="ethernet_ip_settings_invalid_ip">"请填写正确的格式"</string>
    <string name="save_satic_ethernet">"保存"</string>
    <string name="eth_ip_settings_please_complete_settings">"网络信息不完整，请填写完整"</string>
    <string name="enthernet_static">"使用静态设置"</string>
    <string name="enthernet_ip_address">"IP地址"</string>
    <string name="enthernet_gateway">"网关"</string>
    <string name="enthernet_netmask">"子网掩码"</string>
    <string name="enthernet_dns1">"域名1"</string>
    <string name="enthernet_dns2">"域名2"</string>
    <string name="ethernet_quick_toggle_title">"以太网"</string>
    <string name="open_ethernet">"打开以太网"</string>
    <string name="ethernet_static_ip_settings_title">"配置以太网"</string>
    <string name="ethernet_settings">"以太网"</string>
    <string name="ethernet_settings_title">"以太网"</string>
    <string name="calibrate_settings_title">"点击开始进行触屏校准"</string>
    <string name="app_start_error">"未检测到触屏校准程序"</string>

    <string name="ethernet_settings_btn">"点击开始进行以太网配置"</string>


    <string name="calibrate_settings_summry">"(1)首先生成校准用的参数，可以适用tslib生成校准参数，也可以使用校准app生成；使用校准app进行校准对使用者要求比较低，使用者可以不用学习复杂的命令；从用户的角度考虑使用app方式\n"
            "\n"
            "(2)生成校准参数后，以后驱动每次接收到触摸事件就会使用校准参数进行校准"</string>




</resources>
