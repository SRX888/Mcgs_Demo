<resources>
    <string name="app_name">Mcgs</string>
    <string name="title_docment">文档</string>
    <string name="title_application">应用</string>
    <string name="title_settings">设置</string>


    <string name="app_rotation_title">屏幕旋转</string>


    <string name="ethernet_documentation">"通过比较网桥优先级选取根网桥(给定广播域内只有一个根网桥)。\n" +
            "\n" +
            "·其余的非根网桥只有一个通向根交换机的端口称为根端口。\n" +
            "\n" +
            "·每个网段只有一个转发端口。\n" +
            "\n" +
            "·根交换机所有的连接端口均为转发端口。\n" +
            "\n" +
            "注意:生成树协议在交换机上一般是默认开启的,不经人工干预即可正常工作。但这种自动生成的方案可能导致数据传输的路径并非最优化。因此,可以通过人工设置网桥优先级的方法影响生成树的生成结果。\n" +
            "\n" +
            "生成树的状态:\n" +
            "\n" +
            "运行生成树协议的交换机上的端口,总是处于下面四个状态中的一个。在正常操作期间,端口处于转发或阻塞状态。当设备识别网络拓扑结构变化时,交换机自动进行状态转换,在这期间端口暂时处于监听和学习状态。\n" +
            "\n" +
            "阻塞:所有端口以阻塞状态启动以防止回路。由生成树确定哪个端口转换到转发状态,处于阻塞状态的端口不转发数据但可接受BPDU。\n" +
            "\n" +
            "监听:不转发,检测BPDU,(临时状态)。\n" +
            "\n" +
            "学习:不转发,学习MAC地址表(临时状态)。\n" +
            "\n" +
            "转发:端口能转送和接受数据。\n" +
            "\n" +
            "小知识:实际上,在真正使用交换机时还可能出现一种特殊的端口状态-Disabl e状态。这是由于端口故障或由于错误的交换机配置而导致数据冲突造成的死锁状态。如果并非是端口故障的原因,我们可以通过交换机重启来解决这一问题。\n" +
            "\n" +
            "生成树的重计算:\n" +
            "\n" +
            "当网络的拓扑结构发生改变时,生成树协议重新计算,以生成新的生成树结构。当所有交换机的端口状态变为转发或阻塞时,意味着重新计算 完毕。这种状态称为会聚(Convergence)。\n" +
            "当网络的拓扑结构发生改变时,生成树协议重新计算,以生成新的生成树结构。当所有交换机的端口状态变为转发或阻塞时,意味着重新计算完毕。这种状态称为会聚(Convergence)。\n" +
            "\n" +
            "注意:在网络拓扑结构改变期间,设备直到生成树会聚才能进行通信,这可能会对某些应用产生影响,因此一般认为可以使生成树运行良好的交换网络,不应该超过七层。此外可以通过一些特殊的交换机技术加快会聚的时间。\n" +
            "\n" +
            "网桥\n" +
            "\n" +
            "网桥概述:\n" +
            "\n" +
            "依据帧地址进行转发的二层网络设备,可将数个局域网网段连接在一起。网桥可连接相同介质的网段也可访问不同介质的网段。网桥的主要作用是分割和减少冲突。它的工作原理同交换机类似,也是通过MAC地址表进行转发。因此,网桥同交换机没有本质的区别。在某些情况下,我们可以认为网桥就是交换机。\n" +
            "\n" +
            "路由器的简单介绍\n" +
            "\n" +
            "什么是路由器:\n" +
            "\n" +
            "路由器是使用一种或者更多度量因素的网络设备,它决定网络通信能够通过的最佳路径。路由器依据网络层信息将数据包从一个网络前向转发到另一个网络。\n" +
            "\n" +
            "路由器的功能:"</string>
    <string name="serialport_documentation">"说到串口开发，不得不先明确一下以下概念。\n" +
            "\n" +
            "接口的定义：\n" +
            "\n" +
            "接口泛指实体把自己提供给外界的一种抽象化物（可以为另一实体），用以由内部操作分离出外部沟通方法，使其能被修改内部而不影响外界其他实体与其交互的方式。\n" +
            "串行接口的定义：\n" +
            "\n" +
            "串行接口简称 串口，也称 串行通信接口 或 串行通讯接口（通常指COM接口）。是指数据一位一位地顺序传送，其特点是通信线路简单，只要一对传输线就可以实现双向通信，从而大大降低了成本，特别适用于远距离通信，但传送速度较慢。\n" +
            "串口通信的定义：\n" +
            "\n" +
            "串口按位（bit）发送和接收字节。\n" +
            "串口通讯的定义：\n" +
            "\n" +
            "串口通讯(Serial Communication)， 是指外设和计算机间，通过数据信号线 、地线、控制线等，按位进行传输数据的一种通讯方式。一条信息的各位数据被逐位按顺序传送的通讯方式称为串行通讯。"</string>
    <string name="rotation_documentation">"Android 屏幕旋转的机制默认情况下通过重力感应器（G-sensor）来实现的，带有G-sensor的Android设备上可通过API获取到设备的运动加速度，应用程序通过一些假设和算法运算，可以从加速度计算出设备的方向，通过计算出来的值。PhoneWindownManager 通过注册一个ContentObserver来监听用户设置的变化，当用户设置变化后调用updateSettings（）函数，做设置变化的更新和做相应的动作。WindowManagerService完成屏幕旋转的功能，首先更新屏幕方向，然后具体实施屏幕旋转，最后通知AMS configuration变更。\n"
            "\n"
            "上面的所说的都是基于Android设备的具有G-sensor的模块，通过监听G-sensor数据的变化实现屏幕的旋转。但是对于没有G-sensor的模块的设备或者通过想要通过按键来触发屏幕的旋转，怎么实现呢？\n"
            "\n"
            "不管是通过G-sensor设备还是通过按键或者其他的方式来触发屏幕旋转的流程都一样的，只是提供数据的方式有区别而已。\n"
            " \n"
            "\n"
            "\n"
            "其实现机制为：当Configuration改变后，ActivityManagerService将会发送\"配置改变\"的广播，会要求ActivityThread重新启动当前focus的Activity，这是默认情况。如果想很好地支持屏幕旋转，则建议在res中建立layout-land和layout-port两个文件夹，把横屏和竖屏的布局文件放入对应的layout文件夹中。如果不申明android:configChanges=\"\"，按照Activity的生命周期，都会去执行一次onCreate()方法，而onCreate()方法通常会在显示之前做一些初始化工作。这样就有可能造成重复的初始化，必然降低程序效率，而且更有可能因为重复的初始化而导致数据的丢失。\n"
            "\n"
            "\n"
            "\n"
            "目前的A64 Android 设备就是没有G-sensor的模块，具体的实现的就是通过按键或者一些操作模拟G-sensor数据，再把数据传给WindowManagerService，最后通过WindowManagerService判断的接收的数据控制屏幕旋转。\n"
            "\n"
            "\n"
            "现在从Android APP（单个应用的旋转，只有在APP界面内旋转）和系统级别的旋转（一旦选择，不管重启还是其他行为都保持该旋转的模式），分别从0,90,180,270 四个角度进行旋转。\n"
            "\n"
            "\n"
            "（一）APP 四个角度的旋转：\n"
            "在APP界面通过按键来实现APP的旋转\n"
            "有2种方式控制屏幕方向：\n"
            "（1）修改AndroidManifest.xml\n"
            "1 在AndroidManifest.xml的activity中加入:\n"
            "横屏：\n"
            "android:screenOrientation=”landscape”\n"
            "竖屏：\n"
            "android:screenOrientation=”portrait”\n"
            "\n"
            "通过AndroidManifest.xml的配置实现，但是这个有极限性。\n" +
            "\n"
            "（2）setRequestedOrientation函数\n"
            "手动调用setRequestedOrientation之后，假如会引发横竖屏切换（即请求的横竖屏要求与当前的横竖屏情况不一致，就会引发切换），那么会立即调用onConfigurationChanged函数；假如不会引发横竖屏切换（请求前后一致），那么也就不会调用到onConfigurationChanged函数。\n"
            "这个手动调用setRequestedOrientation的地方也可以在Activity中的任何地方，即也可以在onConfigurationChanged中调用，但是一旦指定为横屏或竖屏完成这个变换之后，后面不论屏幕如何进行怎么翻转变化，都不会再触发横竖屏切换了，也即等同于在manifest中设置了android:screenOrientation属性为横屏或竖屏。如果要恢复为响应横竖屏随物理传感器设备变换，那么就需要手动调用类似如下代码进行恢复：\n" 
            "\n"
            "public void onViewClicked(View view) {\n"
            "    int newOrientation = 255;\n"
            "    switch (view.getId()) {\n"
            "        case R.id.rotation_0:\n"
            "            newOrientation = ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT;\n"
            "            break;\n"
            "        case R.id.rotation_1:\n"
            "            newOrientation = ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE;\n"
            "            break;\n"
            "        case R.id.rotation_2:\n"
            "            newOrientation = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;\n"
            "            break;\n"
            "        case R.id.rotation_3:\n"
            "            newOrientation = ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;\n"
            "            break;\n"
            "    }\n"
            "        setRequestedOrientation(newOrientation);\n"
            "}\n"
            "\n"
            "\n"
            "Activity进行默认旋转时候的处理，当屏幕进行旋转的时候会按照横屏的分辨率进行重绘，当然你也可以不进行任何处理难看就难看呗：），理想状态的处理就是建立两套同名的Layout，当屏幕旋转时系统会自动帮我们加载横屏的Layout。在强制重绘的时候旋转过程中可能会出现短暂黑屏（重绘是造成的）\n"
            "\n"
            "\n"
            "DEMO链接：https://github.com/shenruixiang10086/A64RotationDemo\n"
            "APP 旋转方案的请参考github链接\n"
            "\n"
            "\n"
            "\n"
            "\n"
            "（二）系统级别的旋转\n"
            "目前A64 中采用的方法就是系统级别的旋转，就是通过设置可以屏幕分别从0,90,180,270 四个角度进行旋转。一旦设置了系统在任何界面就采用当前的角度，不管设备重启，断电都不影响。在设置的界面分别有0,90,180,270四个角度的设置及一个恢复默认配置的选项。该功能实现的设备可以实现0,90,180,270四个角度的旋转。恢复出厂默认配置用于用户设置其他角度不知道如何设置默认配置的时候可以使用。该功能在系统中Mcgs-demo app中应用中屏幕旋转可以设置。\n"
</string>
    <string name="tp_calibration_documentation">"在Android4.2.2 上基本全部用的都是电容式的触摸屏了，所以Google和其他定制厂商也陆续在自己的Android版本中去掉了电阻屏校准这部分代码，所以在android4.2.2以后已经没有电阻屏校准的source code。\n"
            "\n"
            "目前A64 设备使用的是电阻屏且Android设备的版本是Android 6.0,所以默认的Android source code没有没有屏幕校准功能的，需要移植tslib的源码或者通过APP 来生产校准数据，把校准的数据提供给触屏驱动即可。\n"
            "\n"
            "\n"
            "首先生成校准用的参数，可以使用tslib生成校准参数，也可以使用校准app生成校准参数；考虑到用户的实际使用要求降低，用户可以不用学习复杂的命令及通过一些命令使用tslib来校准。所以本次校准使用APP 方式来校准，使用App 方式来校准大大降低用户的使用难度，没有任何编程基础的用户也能轻松的完成校准。生成校准参数后，以后驱动每次接收到触摸事件就会使用校准参数进行校准。校准之后每次的触摸驱动就使用校准的之后的数据。\n"
            "\n"
            "\n"
            "\n"
            "\n"
            "\n"
            "按照APP提示点击\"十字光标\"进行校准之后，就把校准的数据保存在/data/calibration里，最后把/data/calibration的校准参数传递给tsc2007驱动就完成屏幕的校准。\n"
            "\n"
            "可以使用adb shell cat /data/calibration 命令查看校准的数据，\n"
            "如：\n"
            "adb shell cat /data/calibration\n"
            "11960 473 -2863332 -305 20270 -441608 65536\n"
            "\n"
            "其中11960 473 -2863332 -305 20270 -441608 65536就是校准数据。\n"
            "\n"
            "\n"
            "\n"
            "\n"
            "校准APP简单分析如下：\n"
            "在Activity  onCreate里首先获取到了当前屏幕的宽高：\n"
            "dpy = ((WindowManager) getSystemService(WINDOW_SERVICE)).getDefaultDisplay();\n"
            "X_RES = dpy.getWidth();\n"
            "Y_RES = dpy.getHeight();\n"
            "\n"
            "\n"
            "其中X_RES， Y_RES就代表了当前屏幕的宽高。\n"
            "\n"
            "初始化要触摸点的坐标的方法：\n"
            "// TopLeft-->TopRight-->BottomRight-->BottomLeft-->Center\n"
            "private boolean initScreenPoints() {\n"
            "    cal.xfb[TOP_LEFT] = EDGE_GAP; // TopLeft\n"
            "    cal.yfb[TOP_LEFT] = EDGE_GAP;\n"
            "\n"
            "    cal.xfb[TOP_RIGHT] = X_RES - EDGE_GAP; // TopRight\n"
            "    cal.yfb[TOP_RIGHT] = EDGE_GAP;\n"
            "\n"
            "    cal.xfb[BOTTOM_RIGHT] = X_RES - EDGE_GAP; // BottomRight\n"
            "    cal.yfb[BOTTOM_RIGHT] = Y_RES - EDGE_GAP;\n"
            "\n"
            "    cal.xfb[BOTTOM_LEFT] = EDGE_GAP; // BottomLeft\n"
            "    cal.yfb[BOTTOM_LEFT] = Y_RES - EDGE_GAP;\n"
            "\n"
            "    cal.xfb[CENTER] = X_RES / 2; // Center\n"
            "    cal.yfb[CENTER] = Y_RES / 2;\n"
            "\n"
            "    Log.w(TAG, \"cal.yfb[center] =\" + cal.yfb[CENTER]);\n"
            "\n"
            "    return true;\n"
            "}\n"
            "\n"
            "\n"
            "\n"
            "初始化 5个\"十字光标\"触摸点,分别是 左上角--> 右上角 --> 右下角 --> 左下角 -->正中间，\n"
            "依次点击这5个\"十字光标\"触摸点就可以把校准参数保存在/data/calibration中\n"
            "\n"
            "接着就开始布局了，是new的一个自定义View：\n"
            "setContentView(new MyView(this));\n"
            "\n"
            "\n"
            "\n"
            "ontouchEvent方法监听手指点击事件\n"
            " public boolean onTouchEvent(MotionEvent event) {\n"
            "            float tmpx, tmpy;\n"
            "            boolean ret;\n"
            "            String proGetString=null;\n"
            "            if (screen_pos > SAMPLE_COUNTS - 1) {\n"
            "                Log.i(TAG, \"get sample ok\");\n"
            "                return true;\n"
            "            }\n"
            "\n"
            "            if (event.getAction() == MotionEvent.ACTION_UP) {\n"
            "                tmpx = event.getX();\n"
            "                tmpy = event.getY();\n"
            "                if(Math.abs(cal.xfb[screen_pos]-tmpx)>15 &amp; &amp;\n"
            "                        Math.abs(cal.yfb[screen_pos]-tmpy)>15){\n"
            "                    return false;\n"
            "                }\n"
            "\n"
            "                cal.x[screen_pos] = (int)(event.getX()*4096.0/(float)X_RES + 0.5);\n"
            "                cal.y[screen_pos] = (int)(event.getY()*4096.0/(float)Y_RES + 0.5);\n"
            "\n"
            "                if (screen_pos == 4) {\n"
            "                    ret = perform_calibration();\n"
            "                    if (ret) {\n"
            "                        saveCalibrationResult();\n"
            "                        SystemProperties.set(\"sys.config.calibrate\", \"done\");\n"
            "                        finish();\n"
            "                        return true;\n"
            "                    } else {\n"
            "                        screen_pos = 0;\n"
            "                        Log.w(TAG, \"Calibration failed\");\n"
            "                    }\n"
            "                } else {\n"
            "                    screen_pos++;\n"
            "                    drawCalibrationCross(screen_pos);\n"
            "                }\n"
            "            }\n" +
            "            return true;\n"
            "        }\n"
            "\n"
            "\n"
            "通过ontouchEvent方法监听手指点击事件把点击的事件的产生的数据通过一列的触摸校正算法及逻辑处理把数据转化成的驱动可以使用的诗句，通过saveCalibrationResult（）方法保存起来。\n"
            "\n" +
            "这样就把校准的数据保存到了 /data/calibration中，最后把/data/calibration的校准参数传递给tsc2007驱动就完成屏幕的校准。该功能在系统中Mcgs-demo app中应用中屏幕校准可以设置。\n"
            "\n"
            "\n"
            "\n"</string>
    <string name="usb_set_documentation">"Android通过两种模式，来支持各种USB外围设备和Android USB附件（硬件实现了Android的附件协议）：USB附件模式和USB主机模式。在USB附件模式下，外部 USB 硬件充当USB主机。（作为）附件的例子，包括机器人控制器、扩展插座（docking stations）、诊断和音乐设备、电子报亭（kiosks）、读卡器等其他设备。这种模式给予不具备主机功能的Android设备，与USB硬件通信的能力。Android USB附件，必须被设计为与装有Android的设备一起工作，并且必须遵循Android附件通讯协议。在USB主机模式下，装有Android的设备扮演着主机的角色。（外围）设备的例子，包括数码像机，键盘，鼠标和游戏控制器。那些适应面很广的USB设备，仍可以与Android应用交互，前提是这些Android应用可以正确的与这些设备通讯。\n" +
            "\n" +
            "图1展示了两种模式的异同。当Android设备处于主机模式时，它扮演USB主机角色并为总线供电。当Android设备处于附件模式时，被连接的USB硬件（在这种情况下是一个Android USB附件）扮演主机角色并给总线供电。Android通过两种模式，来支持各种USB外围设备和Android USB附件（硬件实现了Android的附件协议）：USB附件模式和USB主机模式。在USB附件模式下，外部 USB 硬件充当USB主机。（作为）附件的例子，包括机器人控制器、扩展插座（docking stations）、诊断和音乐设备、电子报亭（kiosks）、读卡器等其他设备。这种模式给予不具备主机功能的Android设备，与USB硬件通信的能力。Android USB附件，必须被设计为与装有Android的设备一起工作，并且必须遵循Android附件通讯协议。在USB主机模式下，装有Android的设备扮演着主机的角色。（外围）设备的例子，包括数码像机，键盘，鼠标和游戏控制器。那些适应面很广的USB设备，仍可以与Android应用交互，前提是这些Android应用可以正确的与这些设备通讯。\n" +
            "\n" +
            "图1展示了两种模式的异同。当Android设备处于主机模式时，它扮演USB主机角色并为总线供电。当Android设备处于附件模式时，被连接的USB硬件（在这种情况下是一个Android USB附件）扮演主机角色并给总线供电。Android通过两种模式，来支持各种USB外围设备和Android USB附件（硬件实现了Android的附件协议）：USB附件模式和USB主机模式。在USB附件模式下，外部 USB 硬件充当USB主机。（作为）附件的例子，包括机器人控制器、扩展插座（docking stations）、诊断和音乐设备、电子报亭（kiosks）、读卡器等其他设备。这种模式给予不具备主机功能的Android设备，与USB硬件通信的能力。Android USB附件，必须被设计为与装有Android的设备一起工作，并且必须遵循Android附件通讯协议。在USB主机模式下，装有Android的设备扮演着主机的角色。（外围）设备的例子，包括数码像机，键盘，鼠标和游戏控制器。那些适应面很广的USB设备，仍可以与Android应用交互，前提是这些Android应用可以正确的与这些设备通讯。\n" +
            "\n" +
            "图1展示了两种模式的异同。当Android设备处于主机模式时，它扮演USB主机角色并为总线供电。当Android设备处于附件模式时，被连接的USB硬件（在这种情况下是一个Android USB附件）扮演主机角色并给总线供电。Android通过两种模式，来支持各种USB外围设备和Android USB附件（硬件实现了Android的附件协议）：USB附件模式和USB主机模式。在USB附件模式下，外部 USB 硬件充当USB主机。（作为）附件的例子，包括机器人控制器、扩展插座（docking stations）、诊断和音乐设备、电子报亭（kiosks）、读卡器等其他设备。这种模式给予不具备主机功能的Android设备，与USB硬件通信的能力。Android USB附件，必须被设计为与装有Android的设备一起工作，并且必须遵循Android附件通讯协议。在USB主机模式下，装有Android的设备扮演着主机的角色。（外围）设备的例子，包括数码像机，键盘，鼠标和游戏控制器。那些适应面很广的USB设备，仍可以与Android应用交互，前提是这些Android应用可以正确的与这些设备通讯。\n" +
            "\n" +
            "图1展示了两种模式的异同。当Android设备处于主机模式时，它扮演USB主机角色并为总线供电。当Android设备处于附件模式时，被连接的USB硬件（在这种情况下是一个Android USB附件）扮演主机角色并给总线供电。"</string>
    <string name="rotation_default">屏幕旋转默认角度</string>
    <string name="rotation_90">屏幕旋转90度</string>
    <string name="rotation_180">屏幕旋转180度</string>
    <string name="rotation_270">屏幕旋转270度</string>
    <string name="btn_restore">恢复出厂默认配置</string>
    <string name="btn_restore_message">是否恢复出厂默认配置?</string>
    <string name="rotation_summry">屏幕旋转应用说明：由于该设备没有Sensors没有自动旋转的功能，该功能实现的设备可以实现0,90,180,270四个角度的旋转。恢复出厂默认配置，还原出厂时的默认角度</string>
    <string name="ethernet_on">以太网</string>


    <string name="ethernet_ip_settings_invalid_ip">"请填写正确的格式"</string>
    <string name="save_satic_ethernet">"保存"</string>
    <string name="eth_ip_settings_please_complete_settings">"网络信息不完整，请填写完整"</string>
    <string name="enthernet_static">"使用静态设置"</string>
    <string name="enthernet_ip_address">"IP地址"</string>
    <string name="enthernet_gateway">"网关"</string>
    <string name="enthernet_netmask">"子网掩码"</string>
    <string name="enthernet_dns1">"域名1"</string>
    <string name="enthernet_dns2">"域名2"</string>
    <string name="ethernet_quick_toggle_title">"以太网"</string>
    <string name="open_ethernet">"打开以太网"</string>
    <string name="ethernet_static_ip_settings_title">"配置以太网"</string>
    <string name="ethernet_settings">"以太网"</string>
    <string name="ethernet_settings_title">"以太网"</string>
    <string name="calibrate_settings_title">"点击开始进行触屏校准"</string>
    <string name="app_start_error">"未检测到触屏校准程序"</string>

    <string name="ethernet_settings_btn">"点击开始进行以太网配置"</string>


    <string name="calibrate_settings_summry">"(1)首先生成校准用的参数，可以适用tslib生成校准参数，也可以使用校准app生成；使用校准app进行校准对使用者要求比较低，使用者可以不用学习复杂的命令；从用户的角度考虑使用app方式\n"
            "\n"
            "(2)生成校准参数后，以后驱动每次接收到触摸事件就会使用校准参数进行校准"</string>




</resources>
